{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Formula is a functional reactive framework for managing state and side effects. It enables building deterministic, composable, testable applications. Core concepts Here we will make a simple counter application. It shows the current count and you can increment or decrement it. One of the best practises when working with Formula is to first think what the UI needs for rendering and what actions the user will be able to take. This concept is called a RenderModel and is represented by a Kotlin data class. Render Model Render Model is an immutable representation of your view. It will be used to update Android views. Typically, it will also contain callbacks that will be invoked when user interacts with the UI. data class CounterRenderModel ( val count : String , val onDecrement : () - Unit , val onIncrement : () - Unit ) Once we define a Render Model, we can create a RenderView which is responsible for taking RenderModel and applying it to Android Views. Render View Render View is an interface that we extend. It requires us to create a Renderer that takes RenderModel and applies to it Android Views. Renderer has an internal mechanism that checks the previous Render Model applied and only re-renders if it has changed. class CounterRenderView ( root : ViewGroup ): RenderView CounterRenderModel { private val decrementButton : Button = root . findViewById ( R . id . decrement_button ) private val incrementButton : Button = root . findViewById ( R . id . increment_button ) private val countTextView : TextView = root . findViewById ( R . id . count_text_view ) override val renderer : Renderer CounterRenderModel = Renderer . create { model - countTextView . text = model . count decrementButton . setOnClickListener { model . onDecrement () } incrementButton . setOnClickListener { model . onIncrement () } } } We now defined a single entry-point to our rendering (this makes debugging issues a lot easier). Anytime you need to update UI just set a new Render Model. renderView . renderer . render ( renderModel ) Now that we have our rendering logic setup, let's define how we create the Render Model and handle user events. To have a dynamic UI that changes as user interacts with it requires some sort of state. State State is a Kotlin data class that contains all the necessary information/data to render your view. In our counter example, we need to keep track of the current count. data class CounterState ( val count : Int ) Given, this is a simple state, you could also use Int directly. Formula Formula is responsible for creating the Render Model. It can define an internal State class and respond to various events by transitioning to a new state. class CounterFormula : Formula Unit , CounterState , CounterRenderModel { override fun initialState ( input : Unit ): Int = CounterState ( count = 0 ) override fun evaluate ( input : Unit , state : CounterState , context : FormulaContext Int ): Evaluation CounterRenderModel { val count = state . count return Evaluation ( renderModel = CounterRenderModel ( title = Count: $count , onDecrement = context . callback { transition ( state . copy ( count = count - 1 )) }, onIncrement = context . callback { transition ( state . copy ( count = count + 1 )) } ) ) } } The most import part is the Formula.evaluate function. It gives us Input and current State and expects an Evaluation RenderModel back. Any time we transition to a new state, evaluate is called again and new Render Model is created. There is also a special object called FormulaContext being passed. Formula Context allows us to respond to events by declaring transitions. You see we use context.callback for both onIncrement and onDecrement . onDecrement = context . callback { transition ( state . copy ( count = count - 1 )) } In response to the decrement event, we take the current count and subtract 1 from it. Then, we call transition method to create Transition CounterState object which we return. If you notice, our logic currently allows user to decrement to a number below 0. We can update the transition logic to prevent this. onDecrement = context . callback { if ( count == 0 ) { none () } else { transition ( state . copy ( count = count - 1 )) } } The callback block uses dsl to provide access to Transition.Factory which has the transition and none utility functions (take a look at that class for other utility functions). Now that we defined our state management, let's connect it to our RenderView . Using Formula Formula is agnostic to other layers of abstraction. It can be used within activity or a fragment. You can convert Formula to RxJava2 Observable by using state extension function. val formula = CounterFormula () val state : Observable CounterRenderModel = formula . state ( input = Unit ) Ideally, it would be placed within a surface that survives configuration changes such as Android Components ViewModel. In this example, we will use Formula Android module. For using Formula with AndroidX ViewModel take a look at AndroidX Guide . Let's first define our Activity. class MyActivity : FormulaAppCompatActivity () { lateinit var counterRenderView : CounterRenderView override fun onCreate ( state : Bundle ?) { super . onCreate ( state ) setContentView ( R . string . my_screen ) counterRenderView = CounterRenderView ( findViewById ( R . id . counter )) } fun render ( model : CounterRenderView ) { counterRenderView . renderer . render ( model ) } } Now, let's connect CounterFormula to MyActivity.render function. class MyApp : Application () { override fun onCreate () { super . onCreate () FormulaAndroid . init ( this ) { activity MyActivity { store ( streams = { val formula = CounterFormula () update ( formula . state ( Unit ), MyActivity :: render ) } ) } } } } And that's it. To learn more, see our Formula Android Guide . Download Add JitPack to your list of repositories: repositories { maven { url https://jitpack.io } } And add the library to your list of dependencies: dependencies { implementation com.github.instacart:formula:0.4.0-alpha2 implementation com.github.instacart:formula-android:0.4.0-alpha2 } Inspiration Formula would not have been possible without ideas from other projects such as Elm Cycle.js React / Redux Mobius Square Workflows License The Clear BSD License Copyright (c) 2019 Maplebear Inc. dba Instacart All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted (subject to the limitations in the disclaimer below) provided that the following conditions are met: * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. * Neither the name of Maplebear Inc. dba Instacart nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY S PATENT RIGHTS ARE GRANTED BY THIS LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"Overview"},{"location":"#core-concepts","text":"Here we will make a simple counter application. It shows the current count and you can increment or decrement it. One of the best practises when working with Formula is to first think what the UI needs for rendering and what actions the user will be able to take. This concept is called a RenderModel and is represented by a Kotlin data class.","title":"Core concepts"},{"location":"#render-model","text":"Render Model is an immutable representation of your view. It will be used to update Android views. Typically, it will also contain callbacks that will be invoked when user interacts with the UI. data class CounterRenderModel ( val count : String , val onDecrement : () - Unit , val onIncrement : () - Unit ) Once we define a Render Model, we can create a RenderView which is responsible for taking RenderModel and applying it to Android Views.","title":"Render Model"},{"location":"#render-view","text":"Render View is an interface that we extend. It requires us to create a Renderer that takes RenderModel and applies to it Android Views. Renderer has an internal mechanism that checks the previous Render Model applied and only re-renders if it has changed. class CounterRenderView ( root : ViewGroup ): RenderView CounterRenderModel { private val decrementButton : Button = root . findViewById ( R . id . decrement_button ) private val incrementButton : Button = root . findViewById ( R . id . increment_button ) private val countTextView : TextView = root . findViewById ( R . id . count_text_view ) override val renderer : Renderer CounterRenderModel = Renderer . create { model - countTextView . text = model . count decrementButton . setOnClickListener { model . onDecrement () } incrementButton . setOnClickListener { model . onIncrement () } } } We now defined a single entry-point to our rendering (this makes debugging issues a lot easier). Anytime you need to update UI just set a new Render Model. renderView . renderer . render ( renderModel ) Now that we have our rendering logic setup, let's define how we create the Render Model and handle user events. To have a dynamic UI that changes as user interacts with it requires some sort of state.","title":"Render View"},{"location":"#state","text":"State is a Kotlin data class that contains all the necessary information/data to render your view. In our counter example, we need to keep track of the current count. data class CounterState ( val count : Int ) Given, this is a simple state, you could also use Int directly.","title":"State"},{"location":"#formula","text":"Formula is responsible for creating the Render Model. It can define an internal State class and respond to various events by transitioning to a new state. class CounterFormula : Formula Unit , CounterState , CounterRenderModel { override fun initialState ( input : Unit ): Int = CounterState ( count = 0 ) override fun evaluate ( input : Unit , state : CounterState , context : FormulaContext Int ): Evaluation CounterRenderModel { val count = state . count return Evaluation ( renderModel = CounterRenderModel ( title = Count: $count , onDecrement = context . callback { transition ( state . copy ( count = count - 1 )) }, onIncrement = context . callback { transition ( state . copy ( count = count + 1 )) } ) ) } } The most import part is the Formula.evaluate function. It gives us Input and current State and expects an Evaluation RenderModel back. Any time we transition to a new state, evaluate is called again and new Render Model is created. There is also a special object called FormulaContext being passed. Formula Context allows us to respond to events by declaring transitions. You see we use context.callback for both onIncrement and onDecrement . onDecrement = context . callback { transition ( state . copy ( count = count - 1 )) } In response to the decrement event, we take the current count and subtract 1 from it. Then, we call transition method to create Transition CounterState object which we return. If you notice, our logic currently allows user to decrement to a number below 0. We can update the transition logic to prevent this. onDecrement = context . callback { if ( count == 0 ) { none () } else { transition ( state . copy ( count = count - 1 )) } } The callback block uses dsl to provide access to Transition.Factory which has the transition and none utility functions (take a look at that class for other utility functions). Now that we defined our state management, let's connect it to our RenderView .","title":"Formula"},{"location":"#using-formula","text":"Formula is agnostic to other layers of abstraction. It can be used within activity or a fragment. You can convert Formula to RxJava2 Observable by using state extension function. val formula = CounterFormula () val state : Observable CounterRenderModel = formula . state ( input = Unit ) Ideally, it would be placed within a surface that survives configuration changes such as Android Components ViewModel. In this example, we will use Formula Android module. For using Formula with AndroidX ViewModel take a look at AndroidX Guide . Let's first define our Activity. class MyActivity : FormulaAppCompatActivity () { lateinit var counterRenderView : CounterRenderView override fun onCreate ( state : Bundle ?) { super . onCreate ( state ) setContentView ( R . string . my_screen ) counterRenderView = CounterRenderView ( findViewById ( R . id . counter )) } fun render ( model : CounterRenderView ) { counterRenderView . renderer . render ( model ) } } Now, let's connect CounterFormula to MyActivity.render function. class MyApp : Application () { override fun onCreate () { super . onCreate () FormulaAndroid . init ( this ) { activity MyActivity { store ( streams = { val formula = CounterFormula () update ( formula . state ( Unit ), MyActivity :: render ) } ) } } } } And that's it. To learn more, see our Formula Android Guide .","title":"Using Formula"},{"location":"#download","text":"Add JitPack to your list of repositories: repositories { maven { url https://jitpack.io } } And add the library to your list of dependencies: dependencies { implementation com.github.instacart:formula:0.4.0-alpha2 implementation com.github.instacart:formula-android:0.4.0-alpha2 }","title":"Download"},{"location":"#inspiration","text":"Formula would not have been possible without ideas from other projects such as Elm Cycle.js React / Redux Mobius Square Workflows","title":"Inspiration"},{"location":"#license","text":"The Clear BSD License Copyright (c) 2019 Maplebear Inc. dba Instacart All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted (subject to the limitations in the disclaimer below) provided that the following conditions are met: * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. * Neither the name of Maplebear Inc. dba Instacart nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY S PATENT RIGHTS ARE GRANTED BY THIS LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"License"},{"location":"Fetch-Data/","text":"Let's say your feature needs to fetch an item. Formula uses RxJava to define asynchronous operations. We will assume that you are familiar with Retrofit library. class FetchItemRxStream ( private val itemApi : RetrofitItemApi ) : RxStream FetchItemRxStream . Request , Item { data class Request ( val itemId : String ) override fun observable ( input : Request ): Observable Item { return itemApi . fetchItem ( input . itemId ) } } Now, let's define our Formula. class ItemDetailFormula ( private val fetchItem : FetchItemRxStream ) : Formula Input , State , Unit , RenderMode { data class Input ( val itemId : String ) data class State ( val fetchItemRequest : FetchItemRxStream . Request ? = null , val item : Item ? = null ) override fun initialState ( input : Input ): State { return State ( fetchItemRequest = FetchItemRxStream . Request ( input . itemId )) } override fun evaluate ( input : Input , state : State , context : FormulaContext State , Unit ): Evaluation RenderModel { return Evaluation ( updates = context . updates { if ( state . fetchItemRequest != null ) { events ( fetchItem , state . fetchItemRequest ) { item - state . copy ( fetchItemRequest = null , item = item ). noMessages () } } } ) } } We define fetchItemRequest on our State class and use this property to decide if we want to fetch an item. Once item response arrives, we set the fetchItemRequest to null . Note: we are not handling errors in this example. The best practice is to emit errors as data using the onNext instead of emitting them through onError.","title":"Fetch Data"},{"location":"Getting-Started/","text":"Getting Started A functional reactive framework for managing state and side effects. It enables building deterministic, composable, testable applications. Core concepts State State is a Kotlin data class that contains all the necessary information to render your view. data class CounterState ( val count : Int ) Given, this is a simple state, you could also use Int directly. Render Model Render Model is an immutable representation of your view. It will be used to update the Android views. Typically, it will also contain callbacks that will be invoked when user interacts with the UI. data class CounterRenderModel ( val title : String , val onDecrement : () - Unit , val onIncrement : () - Unit ) Render View Render view is responsible for taking the Render Model and applying it to the Android views. class CounterRenderView ( private val root : ViewGroup ): RenderView CounterRenderModel { private val decrementButton : Button = root . findViewById ( R . id . decrement_button ) private val incrementButton : Button = root . findViewById ( R . id . increment_button ) private val countTextView : TextView = root . findViewById ( R . id . count_text_view ) override val renderer : Renderer CounterRenderModel = Renderer . create { model - countTextView . setText ( model . title ) decrementButton . setOnClickListener { model . onDecrement () } incrementButton . setOnClickListener { model . onIncrement () } } } Formula Creating a counter widget that has increment/decrement buttons. class CounterFormula : Formula Unit , CounterState , CounterRenderModel { override fun initialState ( input : Unit ): Int = CounterState ( count = 0 ) override fun evaluate ( input : Unit , state : CounterState , context : FormulaContext Int ): Evaluation CounterRenderModel { val count = state . count return Evaluation ( renderModel = CounterRenderModel ( title = Count: $count , onDecrement = context . callback { state . copy ( count = count - 1 ). noMessages () }, onIncrement = context . callback { state . copy ( count = count + 1 ). noMessages () } ) ) } } Using Formula Formula is agnostic to other layers of abstraction. It can be used within activity or a fragment. Ideally, it would be placed within a surface that survives configuration changes such as Android Components ViewModel. In this example, I'll show how to connect Formula using Formula Android module. For using Formula with AndroidX ViewModel take a look at AndroidX Guide . Let's first define our Activity. class MyActivity : FormulaAppCompatActivity () { lateinit var counterRenderView : CounterRenderView override fun onCreate ( state : Bundle ?) { super . onCreate ( state ) setContentView ( R . string . my_screen ) counterRenderView = CounterRenderView ( findViewById ( R . id . counter )) } fun render ( model : CounterRenderView ) { counterRenderView . renderer . render ( model ) } } Now, let's connect MyScreenRenderFormula to MyActivity.render function. class MyApp : Application () { override fun onCreate () { super . onCreate () FormulaAndroid . init ( this ) { activity MyActivity { store ( streams = { val formula = CounterFormula () update ( formula . state ( Unit ), MyActivity :: render ) } ) } } } } And that's it. To learn more, see our Formula Android Guide . Listening for events Formula uses RxJava to deal with event streams. You can either use Observable directly or wrap it in a RxStream . Usually event stream dependencies will be passed/injected through the constructor. class MyFormula ( private val dataObservable : Observable MyData ): Formula .... To listen to your data observable, you need to declare a binding within Formula.evaluate block. Evaluation ( renderModel ..., // We declare the event streams within `updates` block updates = context . updates { events ( data , dataObservable ) { update : MyData - // the listener is always scoped to the current `state` so you can update it as part of the transition state . copy ( myData = update ). noMessages () } } ) Note: we use a unique identifier \"data\" to make sure that internal diffing mechanism can distinguish between different streams. Messages Messages are objects used to request execution of impure code. Use messages to execute operations such as logging, database updates, firing network requests, notifying a parent and etc. For example, lets say we want to fire analytics event when user clicks a button. class UserProfileFormula ( val userAnalyticsService : UserAnalyticsService ) : Formula ... { override fun evaluate (...): Evaluation UserProfileRenderModel { return Evaluation ( renderModel = UserProfileRenderModel ( onSaveSelected = context . callback { message ( userAnalyticsService :: trackSaveSelected ) } ) ) } } The main part is the declaration within the context.callback block. context . callback { // We do a state transition and declare 0..N messages that we want to execute. } Input Input is used to pass information/data from the parent to the child. class ItemDetailFormula () : Formula Input , ..., ... { data class Input ( val itemId : String ) override fun evaluate ( input : Input , state : .., context : .. ): Evaluation ... { val itemId = input . itemId // We can use the input here to fetch the item from the repo. } } Passing events to the parent To pass events to the parent, we need to first define the callbacks on the Formula.Input class. data class ItemListInput ( val onItemSelected : ( itemId : String ) - Unit ) Also, lets make sure that Input type is declared at the top of our formula . class ItemListFormula () : Formula ItemListInput , ..., ... Now, we can use the the Message API and the input passed to us in Formula.evaluate to communicate with the parent. override fun evaluate ( input : ItemListInput , state : .., context : .. ): Evaluation ... { return Evaluation ( renderModel = state . items . map { item - context . key ( item . id ) { ItemRow ( name = item . name , onClick = context . callback { // sending a message to `input.onItemSelected` with parameter `item.id` message ( input . onItemSelected , item . id ) } ) } } ) } Note: instead of calling input.onItemSelected(item.id) , we call message(input.onItemSelected, item.id) . This allows formula runtime to ensure that parent is in the right state to handle the message. Composing Render models Render Models are meant to be composable. You can build bigger Render Models from smaller Render Models. data class CheckboxRenderModel ( val text : String , val isChecked : Boolean , val onToggle : () - Unit ) data class NotificationSettingsRenderModel ( val messagePushNotification : CheckboxRenderModel , val promotionalPushNotifications : CheckboxRenderModel , val marketingEmailNotifications : CheckboxRenderModel , val saveSettingsButton : FooterButtonRenderModel ) You can also do the same in your Render View layer. class CheckboxRenderView ( private val root : View ) : RenderView CheckboxRenderModel { private val checkbox : Checkbox = root . findViewById ( R . id . checkbox ) override val renderer : Renderer CheckboxRenderModel = Renderer . create { model - checkbox . text = model . title checkbox . isChecked = model . isChecked checkbox . setOnCheckedListener { model . onToggle () } } } class NotificationSettingsRenderView ( private val root : View ) : RenderView NotificationSettingsRenderModel { private val messagePushNotification = CheckboxRenderView ( root . findViewById ( R . id . message_push_checkbox )) private val promotionalPushNotifications = CheckboxRenderView ( root . findViewById ( R . id . promotional_push_checkbox )) private val marketingEmailNotifications = CheckboxRenderView ( root . findViewById ( R . id . marketing_email_checkbox )) private val saveButton = FooterButtonRenderView ( root . findViewById ( R . id . save_button )) override val renderer : Renderer NotificationSettingsRenderModel = Renderer . create { model - messagePushNotification . renderer . render ( model . messagePushNotification ) promotionalPushNotifications . renderer . render ( model . promotionalPushNotifications ) marketingEmailNotifications . renderer . render ( model . marketingEmailNotifications ) saveButton . renderer . render ( model . saveSettingsButton ) } } Composing formulas You can pass other formulas through the constructor class MainPageFormula ( val headerFormula : HeaderFormula , val listFormula : ListFormula , val dialogFormula : DialogFormula ) : Formula Use FormulaContext.child within Formula.evaluate to hook them up. val listRenderModel = context . child ( listFormula ) . input { ListInput ( items = state . items , onItemSelected = context . eventCallback { // you can respond to child event } } Here is a more complete example: class MainPageFormula ( val headerFormula : HeaderFormula , val listFormula : ListFormula , val dialogFormula : DialogFormula ) : Formula { override fun evaluate ( input : Unit , state : MyState , context : FormulaContext ... ): Evaluation ... { // context.child returns a RenderModel val listRenderModel = context . child ( listFormula ) . input { createListInput ( state ) } val headerRenderModel = context . child ( headerFormula ) . input { createHeaderInput ( state ) } // We can make decisions using the current `state` about // what children to show val dialog = if ( state . showDialog ) { context . child ( dialogFormula ) . input ( Unit ) } else { null } return Evaluation ( renderModel = MainRenderModel ( header = headerRenderModel , list = listRenderModel , dialog = dialog ) ) } } Diffing Given that we recompute everything with each state change, there is an internal diffing mechanism with Formula. This mechanism ensures that: 1. RxJava streams are only subscribed to once. 2. Children state is persisted across every processing pass. Callbacks To create a UI event callback use context.callback or context.eventCallback within Formula.evaluate method. CounterRenderModel ( onIncrement = context . callback { transition ( state + 1 ) } ) Callbacks retain equality across re-evaluation (such as state changes). By default, we persist the callback in a map where each callback is identified by it's class type. In one case this is not sufficient and you need to explicitly provide a unique key . This special condition is when declaring callbacks within a loop. For example, if you are mapping list of items and creating a callback within the map function. // This will not work unless your list of items never changes (removal of item or position change). ItemListRenderModel ( items = state . items . map { item - ItemRenderModel ( name = item . name , onSelected = context . callback { // perform a transition } ) } ) To fix it, you should wrap ItemRenderModel creation block in context.key where you pass it an item id . context . key ( item . id ) { ItemRenderModel ( name = item . name , onSelected = context . callback { // perform a transition } ) } For each unique key we have a persisted callback instance that is kept across multiple Formula.evaluate calls. The instance is disabled and removed when your Formula is removed or if you don't create this callback in the current Formula.evaluate call. Testing To simplify testing your Formulas, you can use formula-test module. testImplementation com.github.instacart:formula-test:{latest_version} Testing the last render model emission val subject = MyFormula (). test (). renderModel { assertThat ( this . name ). isEqualTo ( my name ) } If your Formula has children, you can replace their render model output val subject = MyFormula (). test { // Note: we are using mockito to mock ChildRenderModel, you could also manually create it. child ( MyChildFormula :: class , mock ChildRenderModel ()) } To inspect the input that was passed to the child subject . childInput ( MyChildFormula :: class ) { assertThat ( this . property ). isEqualTo ( property ) } You can fake child events subject . childInput ( MyChildFormula :: class ) { this . onEvent ( fake data ) } FAQ Threading The state management should be initialized on the main thread and all the transitions should also happen on the main thread. You will get the following exception if that is not the case. Caused by: java.lang.IllegalStateException: Only thread that created it can trigger transitions. Expected: main, Was: Network 1 Transition already happened. After each transition, formula is re-evaluated and new event listeners are created. If you use an old listener you will see the following exception. Caused by: java.lang.IllegalStateException: Transition already happened. This is using old transition callback: $it.","title":"Getting Started"},{"location":"Getting-Started/#getting-started","text":"A functional reactive framework for managing state and side effects. It enables building deterministic, composable, testable applications.","title":"Getting Started"},{"location":"Getting-Started/#core-concepts","text":"","title":"Core concepts"},{"location":"Getting-Started/#state","text":"State is a Kotlin data class that contains all the necessary information to render your view. data class CounterState ( val count : Int ) Given, this is a simple state, you could also use Int directly.","title":"State"},{"location":"Getting-Started/#render-model","text":"Render Model is an immutable representation of your view. It will be used to update the Android views. Typically, it will also contain callbacks that will be invoked when user interacts with the UI. data class CounterRenderModel ( val title : String , val onDecrement : () - Unit , val onIncrement : () - Unit )","title":"Render Model"},{"location":"Getting-Started/#render-view","text":"Render view is responsible for taking the Render Model and applying it to the Android views. class CounterRenderView ( private val root : ViewGroup ): RenderView CounterRenderModel { private val decrementButton : Button = root . findViewById ( R . id . decrement_button ) private val incrementButton : Button = root . findViewById ( R . id . increment_button ) private val countTextView : TextView = root . findViewById ( R . id . count_text_view ) override val renderer : Renderer CounterRenderModel = Renderer . create { model - countTextView . setText ( model . title ) decrementButton . setOnClickListener { model . onDecrement () } incrementButton . setOnClickListener { model . onIncrement () } } }","title":"Render View"},{"location":"Getting-Started/#formula","text":"Creating a counter widget that has increment/decrement buttons. class CounterFormula : Formula Unit , CounterState , CounterRenderModel { override fun initialState ( input : Unit ): Int = CounterState ( count = 0 ) override fun evaluate ( input : Unit , state : CounterState , context : FormulaContext Int ): Evaluation CounterRenderModel { val count = state . count return Evaluation ( renderModel = CounterRenderModel ( title = Count: $count , onDecrement = context . callback { state . copy ( count = count - 1 ). noMessages () }, onIncrement = context . callback { state . copy ( count = count + 1 ). noMessages () } ) ) } }","title":"Formula"},{"location":"Getting-Started/#using-formula","text":"Formula is agnostic to other layers of abstraction. It can be used within activity or a fragment. Ideally, it would be placed within a surface that survives configuration changes such as Android Components ViewModel. In this example, I'll show how to connect Formula using Formula Android module. For using Formula with AndroidX ViewModel take a look at AndroidX Guide . Let's first define our Activity. class MyActivity : FormulaAppCompatActivity () { lateinit var counterRenderView : CounterRenderView override fun onCreate ( state : Bundle ?) { super . onCreate ( state ) setContentView ( R . string . my_screen ) counterRenderView = CounterRenderView ( findViewById ( R . id . counter )) } fun render ( model : CounterRenderView ) { counterRenderView . renderer . render ( model ) } } Now, let's connect MyScreenRenderFormula to MyActivity.render function. class MyApp : Application () { override fun onCreate () { super . onCreate () FormulaAndroid . init ( this ) { activity MyActivity { store ( streams = { val formula = CounterFormula () update ( formula . state ( Unit ), MyActivity :: render ) } ) } } } } And that's it. To learn more, see our Formula Android Guide .","title":"Using Formula"},{"location":"Getting-Started/#listening-for-events","text":"Formula uses RxJava to deal with event streams. You can either use Observable directly or wrap it in a RxStream . Usually event stream dependencies will be passed/injected through the constructor. class MyFormula ( private val dataObservable : Observable MyData ): Formula .... To listen to your data observable, you need to declare a binding within Formula.evaluate block. Evaluation ( renderModel ..., // We declare the event streams within `updates` block updates = context . updates { events ( data , dataObservable ) { update : MyData - // the listener is always scoped to the current `state` so you can update it as part of the transition state . copy ( myData = update ). noMessages () } } ) Note: we use a unique identifier \"data\" to make sure that internal diffing mechanism can distinguish between different streams.","title":"Listening for events"},{"location":"Getting-Started/#messages","text":"Messages are objects used to request execution of impure code. Use messages to execute operations such as logging, database updates, firing network requests, notifying a parent and etc. For example, lets say we want to fire analytics event when user clicks a button. class UserProfileFormula ( val userAnalyticsService : UserAnalyticsService ) : Formula ... { override fun evaluate (...): Evaluation UserProfileRenderModel { return Evaluation ( renderModel = UserProfileRenderModel ( onSaveSelected = context . callback { message ( userAnalyticsService :: trackSaveSelected ) } ) ) } } The main part is the declaration within the context.callback block. context . callback { // We do a state transition and declare 0..N messages that we want to execute. }","title":"Messages"},{"location":"Getting-Started/#input","text":"Input is used to pass information/data from the parent to the child. class ItemDetailFormula () : Formula Input , ..., ... { data class Input ( val itemId : String ) override fun evaluate ( input : Input , state : .., context : .. ): Evaluation ... { val itemId = input . itemId // We can use the input here to fetch the item from the repo. } }","title":"Input"},{"location":"Getting-Started/#passing-events-to-the-parent","text":"To pass events to the parent, we need to first define the callbacks on the Formula.Input class. data class ItemListInput ( val onItemSelected : ( itemId : String ) - Unit ) Also, lets make sure that Input type is declared at the top of our formula . class ItemListFormula () : Formula ItemListInput , ..., ... Now, we can use the the Message API and the input passed to us in Formula.evaluate to communicate with the parent. override fun evaluate ( input : ItemListInput , state : .., context : .. ): Evaluation ... { return Evaluation ( renderModel = state . items . map { item - context . key ( item . id ) { ItemRow ( name = item . name , onClick = context . callback { // sending a message to `input.onItemSelected` with parameter `item.id` message ( input . onItemSelected , item . id ) } ) } } ) } Note: instead of calling input.onItemSelected(item.id) , we call message(input.onItemSelected, item.id) . This allows formula runtime to ensure that parent is in the right state to handle the message.","title":"Passing events to the parent"},{"location":"Getting-Started/#composing-render-models","text":"Render Models are meant to be composable. You can build bigger Render Models from smaller Render Models. data class CheckboxRenderModel ( val text : String , val isChecked : Boolean , val onToggle : () - Unit ) data class NotificationSettingsRenderModel ( val messagePushNotification : CheckboxRenderModel , val promotionalPushNotifications : CheckboxRenderModel , val marketingEmailNotifications : CheckboxRenderModel , val saveSettingsButton : FooterButtonRenderModel ) You can also do the same in your Render View layer. class CheckboxRenderView ( private val root : View ) : RenderView CheckboxRenderModel { private val checkbox : Checkbox = root . findViewById ( R . id . checkbox ) override val renderer : Renderer CheckboxRenderModel = Renderer . create { model - checkbox . text = model . title checkbox . isChecked = model . isChecked checkbox . setOnCheckedListener { model . onToggle () } } } class NotificationSettingsRenderView ( private val root : View ) : RenderView NotificationSettingsRenderModel { private val messagePushNotification = CheckboxRenderView ( root . findViewById ( R . id . message_push_checkbox )) private val promotionalPushNotifications = CheckboxRenderView ( root . findViewById ( R . id . promotional_push_checkbox )) private val marketingEmailNotifications = CheckboxRenderView ( root . findViewById ( R . id . marketing_email_checkbox )) private val saveButton = FooterButtonRenderView ( root . findViewById ( R . id . save_button )) override val renderer : Renderer NotificationSettingsRenderModel = Renderer . create { model - messagePushNotification . renderer . render ( model . messagePushNotification ) promotionalPushNotifications . renderer . render ( model . promotionalPushNotifications ) marketingEmailNotifications . renderer . render ( model . marketingEmailNotifications ) saveButton . renderer . render ( model . saveSettingsButton ) } }","title":"Composing Render models"},{"location":"Getting-Started/#composing-formulas","text":"You can pass other formulas through the constructor class MainPageFormula ( val headerFormula : HeaderFormula , val listFormula : ListFormula , val dialogFormula : DialogFormula ) : Formula Use FormulaContext.child within Formula.evaluate to hook them up. val listRenderModel = context . child ( listFormula ) . input { ListInput ( items = state . items , onItemSelected = context . eventCallback { // you can respond to child event } } Here is a more complete example: class MainPageFormula ( val headerFormula : HeaderFormula , val listFormula : ListFormula , val dialogFormula : DialogFormula ) : Formula { override fun evaluate ( input : Unit , state : MyState , context : FormulaContext ... ): Evaluation ... { // context.child returns a RenderModel val listRenderModel = context . child ( listFormula ) . input { createListInput ( state ) } val headerRenderModel = context . child ( headerFormula ) . input { createHeaderInput ( state ) } // We can make decisions using the current `state` about // what children to show val dialog = if ( state . showDialog ) { context . child ( dialogFormula ) . input ( Unit ) } else { null } return Evaluation ( renderModel = MainRenderModel ( header = headerRenderModel , list = listRenderModel , dialog = dialog ) ) } }","title":"Composing formulas"},{"location":"Getting-Started/#diffing","text":"Given that we recompute everything with each state change, there is an internal diffing mechanism with Formula. This mechanism ensures that: 1. RxJava streams are only subscribed to once. 2. Children state is persisted across every processing pass.","title":"Diffing"},{"location":"Getting-Started/#callbacks","text":"To create a UI event callback use context.callback or context.eventCallback within Formula.evaluate method. CounterRenderModel ( onIncrement = context . callback { transition ( state + 1 ) } ) Callbacks retain equality across re-evaluation (such as state changes). By default, we persist the callback in a map where each callback is identified by it's class type. In one case this is not sufficient and you need to explicitly provide a unique key . This special condition is when declaring callbacks within a loop. For example, if you are mapping list of items and creating a callback within the map function. // This will not work unless your list of items never changes (removal of item or position change). ItemListRenderModel ( items = state . items . map { item - ItemRenderModel ( name = item . name , onSelected = context . callback { // perform a transition } ) } ) To fix it, you should wrap ItemRenderModel creation block in context.key where you pass it an item id . context . key ( item . id ) { ItemRenderModel ( name = item . name , onSelected = context . callback { // perform a transition } ) } For each unique key we have a persisted callback instance that is kept across multiple Formula.evaluate calls. The instance is disabled and removed when your Formula is removed or if you don't create this callback in the current Formula.evaluate call.","title":"Callbacks"},{"location":"Getting-Started/#testing","text":"To simplify testing your Formulas, you can use formula-test module. testImplementation com.github.instacart:formula-test:{latest_version} Testing the last render model emission val subject = MyFormula (). test (). renderModel { assertThat ( this . name ). isEqualTo ( my name ) } If your Formula has children, you can replace their render model output val subject = MyFormula (). test { // Note: we are using mockito to mock ChildRenderModel, you could also manually create it. child ( MyChildFormula :: class , mock ChildRenderModel ()) } To inspect the input that was passed to the child subject . childInput ( MyChildFormula :: class ) { assertThat ( this . property ). isEqualTo ( property ) } You can fake child events subject . childInput ( MyChildFormula :: class ) { this . onEvent ( fake data ) }","title":"Testing"},{"location":"Getting-Started/#faq","text":"","title":"FAQ"},{"location":"Getting-Started/#threading","text":"The state management should be initialized on the main thread and all the transitions should also happen on the main thread. You will get the following exception if that is not the case. Caused by: java.lang.IllegalStateException: Only thread that created it can trigger transitions. Expected: main, Was: Network 1","title":"Threading"},{"location":"Getting-Started/#transition-already-happened","text":"After each transition, formula is re-evaluated and new event listeners are created. If you use an old listener you will see the following exception. Caused by: java.lang.IllegalStateException: Transition already happened. This is using old transition callback: $it.","title":"Transition already happened."},{"location":"Integration/","text":"Formula Android The Android module provides a declarative API to connect reactive state management to Android Fragments. This module has been designed for gradual adoption. You can use as much or as little of it as you like. Some of the goals for this module are: - Use single RxJava stream to drive the UI. - Separate state management from Android UI lifecycle. - Ability to group multiple fragments into a flow and share state between them. - Type-safe and scoped fragment event handling. (Avoid casting activity to a listener) Getting Started For the getting started guide, we will build a timer which you can reset. This is a simple example, but it will be sufficient to display some of the concepts around this module. Defining the render model When working with Formula, usually the first thing we define is what our UI will be rendering and what actions it will perform. Render Model is a class that defines this. class TimerRenderModel ( val time : String , val onResetSelected : () - Unit ) Let's apply this render model to android views We define a fragment contract for how a render model is applied to Android views. // Fragment contract has to provide Parcelable implementation because it is passed to the fragment as an argument. // Read more about Parcelize: https://kotlinlang.org/docs/tutorials/android-plugin.html @Parcelize data class TimerContract ( override val tag : String = timer , override val layoutId : Int = R . layout . timer ) : FragmentContract TimerRenderModel () { // A layout is automatically inflated and the view is passed to this callback. override fun createComponent ( view : View ): FragmentComponent TimerRenderModel { val timerTextView = view . findViewById ( R . id . timer_text_view ) val resetButton = view . findViewById ( R . id . timer_reset_button ) return FragmentComponent . create { renderModel - timerTextView . text = renderModel . time resetButton . setOnClickListener { renderModel . onResetSelected () } } } } Register state management for this screen Fragment contract is used as a navigation destination key. For each of the fragment contract types, we provide a state management factory. This factory has to return an Observable RenderModel . The factory will be invoked when the user enters this destination. class MyApp : Application () { override fun onCreate () { super . onCreate () FormulaAndroid . init ( this ) { activity ( MyActivity :: class ) { store { // Bind function provides type safety - given a TimerContract, // it expects Observable TimerRenderModel from the factory bind ( TimerContract :: class ) { _ , contract - val resetRelay = PublishRelay . create Unit () resetRelay . startWith ( Unit ). switchMap { Observable . interval ( 0 , 1 , TimeUnit . SECONDS ) . observeOn ( AndroidSchedulers . mainThread ()) } . map { TimerRenderModel ( time = $it seconds passed. , onResetSelected = { resetRelay . accept ( Unit ) } ) } } } } } } } For the sake of simplicity, I've inlined the state management logic into the bind function. In a real world example, this logic would live within Formula . The only thing left is navigating to this screen class MyActivity : FormulaAppCompatActivity () { override fun onCreate ( savedInstanceState : Bundle ?) { super . onCreate ( savedInstanceState ) setContentView ( R . layout . my_activity ) if ( savedInstanceState == null ) { val contract = TimerContract () val fragment = FormulaFragment . newInstance ( contract ) // Add the fragment using the fragment transaction API. supportFragmentManager . beginTransaction () . add ( R . id . activity_content , fragment , contract . tag ) . commit () } } } If your Activity has another base class, you can just copy logic from FormulaAppCompatActivity into your Activity . And that's it Formula takes care of the rest. The RxJava state stream is instantiated and subscribed to when the user enters declared navigation destination. We dispose of the stream only when user exits the destination. How to pass arguments such as item id to the fragment? Arguments can be passed using the Fragment contract. @Parcelize data class ItemDetailContract ( val itemId : Int , override val tag : String = item detail ${itemId} , override val layoutId : Int = R . layout . item_detail ) : FragmentContract RenderModelType () { override fun createComponent ( view : View ): FragmentComponent RenderModelType { return TODO () } } The contract is passed to the function that instantiates the state management val store = FragmentFlowStore . init { bind ( ItemDetailContract :: class ) { _ , key : ItemDetailContract - // do something with the item id key . itemId } } Fragment Event Handling In fragments, a common pattern for passing events to the parent is casting Activity into a Listener class MyFragment : Fragment () { override fun onAttach ( context : Context ) { listener = context as Listener } override fun onDetach ( context : Context ) { listener = null } } Instead of a listener with methods, we define a sealed class of possible actions that activity can perform. sealed class MyActivityEffect { class ShowToast ( val message : String ): MyActivityEffect () class CloseFragment ( val tag : String ): MyActivityEffect () } class MyActivity : FragmentActivity () { fun onActivityEffect ( effect : MyActivityEffect ) { when ( effect ) { is ShowToast - { Toast . makeText ( this , effect . message , Toast . LENGTH_LONG ). show (); } is CloseFragment - { supportFragmentManager . popBackStack () } } } } We can then use a ActivityProxy MyActivity to trigger this effect. activity ( MyActivity :: class ) { store { bind ( ItemDetailContract :: class ) { _ , contract - val input = ItemDetailFormula . Input ( onItemFavorited = { send { onActivityEffect ( MyActivityEffect . ShowToast ( Item was added to your favorites. )) } }, onItemDeleted = { send { onActivityEffect ( MyActivityEffect . CloseFragment ( contract . tag )) } } ) val formula : ItemDetailFormula = component . createItemDetailFormula () formula . state ( input ) } } } Navigation To trigger navigation from one screen to another, we add a new type to the MyActivityEffect sealed class. sealed class MyActivityEffect { ... class NavigateToFragmentContract ( val contract : FragmentContract * ): MyActivityEffect () } Now, we can trigger it from event callback such as onItemSelected activity ( MyActivity :: class ) { store { bind ( ItemListContract :: class ) { _ , contract - // Provide callbacks to item list feature events. val input = ItemListFormula . Input ( onItemSelected = { item - val contract = ItemDetailContract ( id = item . id ) send { onActivityEffect ( ActivityEffect . NavigateToFragmentContract ( contract )) } } ) // Hook up the formula state management val formula : ItemListFormula = ... formula . state ( input ) } } } In our activity, we can react to this effect and perform the navigation class MyActivity : FormulaAppCompatActivity () { fun onActivityEffect ( effect : MyActivityEffect ) { when ( effect ) { is NavigateToFragmentContract - { // Perform navigation using fragment transaction val fragment = FormulaFragment . newInstance ( effect . contract ) supportFragmentManager . beginTransaction () . replace ( R . id . fragment_container , fragment , effect . contract . tag ) . addToBackStack ( null ) . commit () } } } } Grouping multiple navigation destinations as part of a flow. Flow is a combination of screens that are grouped together and can share a common component / state. class MyFlowDeclaration : FlowDeclaration MyFlowDeclaration . Component () { // Define the shared component for the flow class Component ( val sharedService : MyFlowService , val onSomeEvent : () - Unit ) override fun createFlow (): Flow Component { return build { bind ( Contract1 :: class ) { component , contract - TODO ( return an RxJava state stream that drives the UI ) } bind ( Contract2 :: class ) { component , contract - TODO ( return an RxJava state stream that drives the UI ) } } } } Moving integration into a separate class When you reach a certain number of fragment integrations, the store creation logic can become unwieldy. To keep it tidy, you can place integration logic into separate class. object TaskDetailIntegration : Integration TaskAppComponent , TaskDetailContract , TaskDetailRenderModel () { override fun create ( component : TaskAppComponent , key : TaskDetailContract ): Observable TaskDetailRenderModel { return component . taskRepo . findTask ( taskId ). map { task - TaskDetailRenderModel ( description = task . description , onDeleteSelected = { component . taskRepo . delete ( taskId ) } ) } } } Now we can update our store to use this integration. val store = FragmentFlowStore . init ( taskAppComponent ) { bind ( TaskDetailIntegration ) // Other integrations. bind ( Contract1Integration ) bind ( Contract2Integration ) } Handling back button events To override how the back button works for a particular navigation destination, your render model needs to implement BackCallback interface. data class FormRenderModel ( private val confirmBeforeExiting : Boolean , private val confirmUserWantsToExit : () - Unit ): BackCallback { fun onBackPressed (): Boolean { // Check if we need to override back handling if ( confirmBeforeExiting ) { confirmUserWantsToExit () return true } // Use default behavior (which closes the screen) return false } } Your Activity needs to call FormulaAndroid.onBackPressed() . It will check if your current screen implements BackCallback and will invoke it. class MyActivity : FragmentActivity () { override fun onBackPressed () { if (! FormulaAndroid . onBackPressed ( this )) { super . onBackPressed () } } } Activity state management One of the goals of Formula is to make doing the right thing easy. As part of that we wanted to provide an easy way for state streams to survive configuration changes by default. Let's define a basic activity that has a renderTime method. class MyActivity : FormulaAppCompatActivity () { fun renderTime ( time : String ) { // implementation left to the reader } } To connect an RxJava Observable to renderTime , we define streams parameter which expects a Disposable back. Within this method you can subscribe to any number of RxJava streams. class MyApp : Application () { override fun onCreate () { super . onCreate () FormulaAndroid . init ( this ) { activity MyActivity { store ( streams = { // You can subscribe to your RxJava streams here. val timerState = Observable . interval ( 0 , 1 , TimeUnit . SECONDS ) . observeOn ( AndroidSchedulers . mainThread ()) . map { time - $time seconds } // update ensures that if configuration changes happen that // we send the last state to the new activity instance. update ( timerState , MyActivity :: renderTime ) } ) } } } } You might be confused about the update function called there. It is provided within the context of streams function using Kotlin receiver parameter StreamConfigurator . The update function ensures that state changes only arrive after Activity has started and that last state is applied if Activity is re-created due to configuration changes. It returns a Disposable . Managing dependencies Managing dependencies in Formula is very easy. In the function that instantiates the ActivityStore for your activity, you can create your activity specific dependencies or Dagger components. These objects will survive configuration changes. class MyApp : Application () { override fun onCreate () { super . onCreate () val appComponent : AppComponent = ... FormulaAndroid . init ( this ) { activity ( MyActivity :: class ) { // This component will survive configuration changes. val activityComponent = appComponent . createMyActivityComponent () store { } } } } } To inject the activity or create activity dependencies that don't survive configuration changes such as ones that need direct activity reference, you can use configureActivity callback. val appComponent : AppComponent = ... FormulaAndroid . init ( this ) { activity ( MyActivity :: class ) { // This component will survive configuration changes. val activityComponent = appComponent . createMyActivityComponent () store ( configureActivity = { // in this callback `this` is the instance of MyActivity // so we can use it to inject dependencies activityComponent . inject ( this ) // Or you can use setters to provide dependencies to your activity. // This dependency object won t survive configuration changes. val dependency = MyActivityDependency ( activity = this ) this . setDependency ( dependency ) } ) } }","title":"Formula Android"},{"location":"Integration/#formula-android","text":"The Android module provides a declarative API to connect reactive state management to Android Fragments. This module has been designed for gradual adoption. You can use as much or as little of it as you like. Some of the goals for this module are: - Use single RxJava stream to drive the UI. - Separate state management from Android UI lifecycle. - Ability to group multiple fragments into a flow and share state between them. - Type-safe and scoped fragment event handling. (Avoid casting activity to a listener)","title":"Formula Android"},{"location":"Integration/#getting-started","text":"For the getting started guide, we will build a timer which you can reset. This is a simple example, but it will be sufficient to display some of the concepts around this module.","title":"Getting Started"},{"location":"Integration/#defining-the-render-model","text":"When working with Formula, usually the first thing we define is what our UI will be rendering and what actions it will perform. Render Model is a class that defines this. class TimerRenderModel ( val time : String , val onResetSelected : () - Unit )","title":"Defining the render model"},{"location":"Integration/#lets-apply-this-render-model-to-android-views","text":"We define a fragment contract for how a render model is applied to Android views. // Fragment contract has to provide Parcelable implementation because it is passed to the fragment as an argument. // Read more about Parcelize: https://kotlinlang.org/docs/tutorials/android-plugin.html @Parcelize data class TimerContract ( override val tag : String = timer , override val layoutId : Int = R . layout . timer ) : FragmentContract TimerRenderModel () { // A layout is automatically inflated and the view is passed to this callback. override fun createComponent ( view : View ): FragmentComponent TimerRenderModel { val timerTextView = view . findViewById ( R . id . timer_text_view ) val resetButton = view . findViewById ( R . id . timer_reset_button ) return FragmentComponent . create { renderModel - timerTextView . text = renderModel . time resetButton . setOnClickListener { renderModel . onResetSelected () } } } }","title":"Let's apply this render model to android views"},{"location":"Integration/#register-state-management-for-this-screen","text":"Fragment contract is used as a navigation destination key. For each of the fragment contract types, we provide a state management factory. This factory has to return an Observable RenderModel . The factory will be invoked when the user enters this destination. class MyApp : Application () { override fun onCreate () { super . onCreate () FormulaAndroid . init ( this ) { activity ( MyActivity :: class ) { store { // Bind function provides type safety - given a TimerContract, // it expects Observable TimerRenderModel from the factory bind ( TimerContract :: class ) { _ , contract - val resetRelay = PublishRelay . create Unit () resetRelay . startWith ( Unit ). switchMap { Observable . interval ( 0 , 1 , TimeUnit . SECONDS ) . observeOn ( AndroidSchedulers . mainThread ()) } . map { TimerRenderModel ( time = $it seconds passed. , onResetSelected = { resetRelay . accept ( Unit ) } ) } } } } } } } For the sake of simplicity, I've inlined the state management logic into the bind function. In a real world example, this logic would live within Formula .","title":"Register state management for this screen"},{"location":"Integration/#the-only-thing-left-is-navigating-to-this-screen","text":"class MyActivity : FormulaAppCompatActivity () { override fun onCreate ( savedInstanceState : Bundle ?) { super . onCreate ( savedInstanceState ) setContentView ( R . layout . my_activity ) if ( savedInstanceState == null ) { val contract = TimerContract () val fragment = FormulaFragment . newInstance ( contract ) // Add the fragment using the fragment transaction API. supportFragmentManager . beginTransaction () . add ( R . id . activity_content , fragment , contract . tag ) . commit () } } } If your Activity has another base class, you can just copy logic from FormulaAppCompatActivity into your Activity .","title":"The only thing left is navigating to this screen"},{"location":"Integration/#and-thats-it","text":"Formula takes care of the rest. The RxJava state stream is instantiated and subscribed to when the user enters declared navigation destination. We dispose of the stream only when user exits the destination.","title":"And that's it"},{"location":"Integration/#how-to-pass-arguments-such-as-item-id-to-the-fragment","text":"Arguments can be passed using the Fragment contract. @Parcelize data class ItemDetailContract ( val itemId : Int , override val tag : String = item detail ${itemId} , override val layoutId : Int = R . layout . item_detail ) : FragmentContract RenderModelType () { override fun createComponent ( view : View ): FragmentComponent RenderModelType { return TODO () } } The contract is passed to the function that instantiates the state management val store = FragmentFlowStore . init { bind ( ItemDetailContract :: class ) { _ , key : ItemDetailContract - // do something with the item id key . itemId } }","title":"How to pass arguments such as item id to the fragment?"},{"location":"Integration/#fragment-event-handling","text":"In fragments, a common pattern for passing events to the parent is casting Activity into a Listener class MyFragment : Fragment () { override fun onAttach ( context : Context ) { listener = context as Listener } override fun onDetach ( context : Context ) { listener = null } } Instead of a listener with methods, we define a sealed class of possible actions that activity can perform. sealed class MyActivityEffect { class ShowToast ( val message : String ): MyActivityEffect () class CloseFragment ( val tag : String ): MyActivityEffect () } class MyActivity : FragmentActivity () { fun onActivityEffect ( effect : MyActivityEffect ) { when ( effect ) { is ShowToast - { Toast . makeText ( this , effect . message , Toast . LENGTH_LONG ). show (); } is CloseFragment - { supportFragmentManager . popBackStack () } } } } We can then use a ActivityProxy MyActivity to trigger this effect. activity ( MyActivity :: class ) { store { bind ( ItemDetailContract :: class ) { _ , contract - val input = ItemDetailFormula . Input ( onItemFavorited = { send { onActivityEffect ( MyActivityEffect . ShowToast ( Item was added to your favorites. )) } }, onItemDeleted = { send { onActivityEffect ( MyActivityEffect . CloseFragment ( contract . tag )) } } ) val formula : ItemDetailFormula = component . createItemDetailFormula () formula . state ( input ) } } }","title":"Fragment Event Handling"},{"location":"Integration/#navigation","text":"To trigger navigation from one screen to another, we add a new type to the MyActivityEffect sealed class. sealed class MyActivityEffect { ... class NavigateToFragmentContract ( val contract : FragmentContract * ): MyActivityEffect () } Now, we can trigger it from event callback such as onItemSelected activity ( MyActivity :: class ) { store { bind ( ItemListContract :: class ) { _ , contract - // Provide callbacks to item list feature events. val input = ItemListFormula . Input ( onItemSelected = { item - val contract = ItemDetailContract ( id = item . id ) send { onActivityEffect ( ActivityEffect . NavigateToFragmentContract ( contract )) } } ) // Hook up the formula state management val formula : ItemListFormula = ... formula . state ( input ) } } } In our activity, we can react to this effect and perform the navigation class MyActivity : FormulaAppCompatActivity () { fun onActivityEffect ( effect : MyActivityEffect ) { when ( effect ) { is NavigateToFragmentContract - { // Perform navigation using fragment transaction val fragment = FormulaFragment . newInstance ( effect . contract ) supportFragmentManager . beginTransaction () . replace ( R . id . fragment_container , fragment , effect . contract . tag ) . addToBackStack ( null ) . commit () } } } }","title":"Navigation"},{"location":"Integration/#grouping-multiple-navigation-destinations-as-part-of-a-flow","text":"Flow is a combination of screens that are grouped together and can share a common component / state. class MyFlowDeclaration : FlowDeclaration MyFlowDeclaration . Component () { // Define the shared component for the flow class Component ( val sharedService : MyFlowService , val onSomeEvent : () - Unit ) override fun createFlow (): Flow Component { return build { bind ( Contract1 :: class ) { component , contract - TODO ( return an RxJava state stream that drives the UI ) } bind ( Contract2 :: class ) { component , contract - TODO ( return an RxJava state stream that drives the UI ) } } } }","title":"Grouping multiple navigation destinations as part of a flow."},{"location":"Integration/#moving-integration-into-a-separate-class","text":"When you reach a certain number of fragment integrations, the store creation logic can become unwieldy. To keep it tidy, you can place integration logic into separate class. object TaskDetailIntegration : Integration TaskAppComponent , TaskDetailContract , TaskDetailRenderModel () { override fun create ( component : TaskAppComponent , key : TaskDetailContract ): Observable TaskDetailRenderModel { return component . taskRepo . findTask ( taskId ). map { task - TaskDetailRenderModel ( description = task . description , onDeleteSelected = { component . taskRepo . delete ( taskId ) } ) } } } Now we can update our store to use this integration. val store = FragmentFlowStore . init ( taskAppComponent ) { bind ( TaskDetailIntegration ) // Other integrations. bind ( Contract1Integration ) bind ( Contract2Integration ) }","title":"Moving integration into a separate class"},{"location":"Integration/#handling-back-button-events","text":"To override how the back button works for a particular navigation destination, your render model needs to implement BackCallback interface. data class FormRenderModel ( private val confirmBeforeExiting : Boolean , private val confirmUserWantsToExit : () - Unit ): BackCallback { fun onBackPressed (): Boolean { // Check if we need to override back handling if ( confirmBeforeExiting ) { confirmUserWantsToExit () return true } // Use default behavior (which closes the screen) return false } } Your Activity needs to call FormulaAndroid.onBackPressed() . It will check if your current screen implements BackCallback and will invoke it. class MyActivity : FragmentActivity () { override fun onBackPressed () { if (! FormulaAndroid . onBackPressed ( this )) { super . onBackPressed () } } }","title":"Handling back button events"},{"location":"Integration/#activity-state-management","text":"One of the goals of Formula is to make doing the right thing easy. As part of that we wanted to provide an easy way for state streams to survive configuration changes by default. Let's define a basic activity that has a renderTime method. class MyActivity : FormulaAppCompatActivity () { fun renderTime ( time : String ) { // implementation left to the reader } } To connect an RxJava Observable to renderTime , we define streams parameter which expects a Disposable back. Within this method you can subscribe to any number of RxJava streams. class MyApp : Application () { override fun onCreate () { super . onCreate () FormulaAndroid . init ( this ) { activity MyActivity { store ( streams = { // You can subscribe to your RxJava streams here. val timerState = Observable . interval ( 0 , 1 , TimeUnit . SECONDS ) . observeOn ( AndroidSchedulers . mainThread ()) . map { time - $time seconds } // update ensures that if configuration changes happen that // we send the last state to the new activity instance. update ( timerState , MyActivity :: renderTime ) } ) } } } } You might be confused about the update function called there. It is provided within the context of streams function using Kotlin receiver parameter StreamConfigurator . The update function ensures that state changes only arrive after Activity has started and that last state is applied if Activity is re-created due to configuration changes. It returns a Disposable .","title":"Activity state management"},{"location":"Integration/#managing-dependencies","text":"Managing dependencies in Formula is very easy. In the function that instantiates the ActivityStore for your activity, you can create your activity specific dependencies or Dagger components. These objects will survive configuration changes. class MyApp : Application () { override fun onCreate () { super . onCreate () val appComponent : AppComponent = ... FormulaAndroid . init ( this ) { activity ( MyActivity :: class ) { // This component will survive configuration changes. val activityComponent = appComponent . createMyActivityComponent () store { } } } } } To inject the activity or create activity dependencies that don't survive configuration changes such as ones that need direct activity reference, you can use configureActivity callback. val appComponent : AppComponent = ... FormulaAndroid . init ( this ) { activity ( MyActivity :: class ) { // This component will survive configuration changes. val activityComponent = appComponent . createMyActivityComponent () store ( configureActivity = { // in this callback `this` is the instance of MyActivity // so we can use it to inject dependencies activityComponent . inject ( this ) // Or you can use setters to provide dependencies to your activity. // This dependency object won t survive configuration changes. val dependency = MyActivityDependency ( activity = this ) this . setDependency ( dependency ) } ) } }","title":"Managing dependencies"},{"location":"Old-Getting-Started/","text":"Getting Started A functional reactive framework for managing state and side effects based on RxJava. It enables building deterministic, composable, testable applications. Core concepts State State is a Kotlin data class that contains all the necessary information to render your view. data class MyScreenState ( val userInfoRequest : Lce UserInfo , val isSaving : Boolean = false ) Note: for info about Lce , please check this article . Render Model Render Model is an immutable representation of your view. It will be used to update the Android views. Typically, it will also contain callbacks that will be invoked when user interacts with the UI. data class FooterButtonRenderModel ( val title : String , val isEnabled : Boolean , val onClick : () - Unit ) Render View Render view is responsible for taking the Render Model and applying it to the Android views. class FooterButtonRenderView ( private val root : View ) : RenderView FooterButtonRenderModel { private val footerButton : Button = root . findViewById ( R . id . footer_button ) override val renderer : Renderer FooterButtonRenderModel = Renderer . create { model - footerButton . text = model . title footerButton . isEnabled = model . isEnabled footerButton . setOnClickListener { model . onClick () } } } Render Model Generator Render Model Generator takes a State and creates a Render Model from it. class MyScreenRenderModelGenerator ( private val onSaveUserInfoSelected : () - Unit ) : RenderModelGenerator MyScreenState , FooterButtonRenderModel { override fun toRenderModel ( state : MyScreenState ): FooterButtonRenderModel { return FooterButtonRenderModel ( title = Save User Info , isEnabled = state . userInfoRequest . isData () ! state . isSaving , onClick = onSaveUserInfoSelected ) } } Reducers Reducers class defines all the possible State transformations. It defines methods that take an event object and return a transformation. Instead of of mutating properties when an event happens, we create a new version of the State class. To accomplish that, we use data class copy method. class MyScreenReducers : Reducers MyScreenState , Unit () { fun onUserInfoRequest ( event : Lce UserInfo ) = withoutEffects { state - state . copy ( userInfoRequest = event ) } fun onSaveUserInfoRequest ( event : Lce SaveUserInfoResponse ) = withoutEffects { state - state . copy ( isSaving = event . isLoading ()) } } Render Formula Render Formula is responsible for state management. It combines various RxJava event streams and maps them to state transformations. class MyScreenRenderFormula ( private val userRepo : UserRepo ) : RenderFormula Unit , MyScreenState , FooterButtonRenderModel , Unit { override fun createRenderLoop ( input : Unit ): RenderLoop MyScreenState , Unit , FooterButtonRenderModel { val reducers = MyScreenReducers () val userInfoRequestChanges = userRepo . fetchUserInfo (). map ( reducers :: onUserInfoRequest ) // We use a RxRelay library to turn user events into an RxJava stream val saveUserInfoRelay = PublishRelay . create Unit () val saveUserInfoChanges = saveUserInfoRelay . switchMap { userRepo . saveUserInfo () } . map ( reducers :: onSaveUserInfoRequest ) return RenderLoop ( initialState = MyScreenState ( userInfoRequest = Lce . loading () ), reducers = Observable . merge ( userInfoRequestChanges , saveUserInfoChanges ), renderModelGenerator = MyScreeenRenderModelGenerator ( onSaveUserInfoSelected = { saveUserInfoRelay . accept ( Unit ) } ) ) } } Using Render Formula Render formula is agnostic to other layers of abstraction. It can be used within activity or a fragment. Ideally, it would be placed within a surface that survives configuration changes such as Android Components ViewModel. In this example, I'll show how to connect RenderFormula using Formula Android module. Let's first define our Activity. class MyActivity : FormulaAppCompatActivity () { lateinit var footerButtonRenderView : FooterButtonRenderView override fun onCreate ( state : Bundle ?) { super . onCreate ( state ) setContentView ( R . string . my_screen ) footerButtonRenderView = FooterButtonRenderView ( findViewById ( R . id . footer )) } fun render ( model : FooterButtonRenderModel ) { footerButtonRenderView . renderer . render ( model ) } } Now, let's connect MyScreenRenderFormula to MyActivity.render function. class MyApp : Application () { override fun onCreate () { super . onCreate () FormulaAndroid . init ( this ) { activity MyActivity { store ( streams = { val formula : MyScreenRenderFormula = ... update ( formula . state ( Unit ), MyActivity :: render ) } ) } } } } And that's it. To learn more, see our Formula Android Guide . Using Render Formula with Android View Model Defining ViewModel which runs Formula.state stream until onCleared is called. class MyViewModel ( private val formula : MyScreenRenderFormula ) : ViewModel { private val disposables = CompositeDisposable () val renderModels = formula . state ( Unit ). replay ( 1 ). apply { connect { disposables . add ( it ) } } override fun onCleared () { super . onCleared () disposables . clear () } } In our activity, we then subscribe to the Render Model changes and pass them to the Render View. class MyActivity : AppCompatActivity () { private val disposables = CompositeDisposable () override fun onCreate ( state : Bundle ?) { super . onCreate ( state ) setContentView ( R . string . my_screen ) val renderView = FooterButtonRenderView ( findViewById ( R . id . activity_content )) val viewModel = ViewModelProviders . of ( this ). get ( MyViewModel :: class . java ) disposables . add ( viewModel . renderModels . subscribe ( renderView . renderer :: render )) } override fun onDestroy () { disposables . clear () super . onDestroy () } } Input Input is used to pass information when creating a state stream. Typically it will contain data necessary to initialize the state streams, and callbacks for events that the parent should be aware of. class ItemDetailRenderFormula () : RenderFormula Input , ..., ..., ... { class Input ( val itemId : String , val onItemDeleted : () - Unit ) override fun createRenderLoop ( input : Input ): RenderLoop ... { // We can use the input here to fetch the item from the repo. // We can also notify the parent when the item is deleted using input.onItemDeleted() } } Effects Effects are message objects used to request the execution of impure code. Operations such as firing a network request, reading / writing to disk, navigation or updating global state are considered side-effects. Instead of performing those operations within the Reducers class, we return the Effect object and let the caller execute the side effect. Typically, we define all possible side-effects as a sealed Kotlin class. sealed class MyScreenEffect { data class ShowErrorModal ( val errorMessage : String ): MyScreenEffect () data class Exit ( val savedUserInfo : Boolean ): MyScreenEffect () } To emit effect class MyScreenReducers : Reducers ..., MyScreenEffect () { fun onSaveUserInfoRequest ( event : Lce SaveUserInfoResponse ) = reduce { val updated = it . copy ( isSaving = event . isLoading ()) // Check if there are side effects val effect = if ( event . isData ()) { // We want to close the screen when user info is saved. MyScreenEffect . Exit ( savedUserInfo = true ) } else if ( event . isError ()) { MyScreenEffect . ShowErrorModal ( errorMessage = event . error . getMessage ()) } else { null } updated . withOptionalEffect ( effect ) } } Within the Render Formula, we can decide how to handle the effects. class MyScreenRenderFormula : RenderFormula ..., ..., MyScreenEffect , ... { override fun createRenderLoop ( input : ...): RenderLoop ..., MyScreenEffect , ... { return RenderLoop ( ..., onEffect = { effect - // We decide here how to execute the effect. We can // 1. bubble it to the parent using the callbacks passed by the Input object // 2. handle it internally by passing it to a RxRelay or RxJava Subject when ( effect ) { is ShowErrorModal - { } is Exit - { } } } ) } } Handling User UI Actions To handle user UI actions, we set listeners on Android Views and delegate to the callbacks on the Render Model. data class MyRenderModel ( // Defining a callback for a user action. // Usually, callback will not take any parameters. val onSaveButtonClicked : () - Unit ) class MyRenderView (...) : RenderView MyRenderModel { val saveButton : TextView = ... override val renderer : Renderer MyRenderModel = Renderer . create { model - // We just set a click listener and delegate to the callback on the Render Model. saveButton . setOnClickListener { model . onSaveButtonClicked () } } } The Render Model creation will be scoped to the current state object, so we can use it to decide how we should bubble it up. class MyRenderModelGenerator ( // We splitting save button click into two options private val showValidationError : ( String ) - Unit , private val saveUserInfo : ( UserInfo ) - Unit ) : RenderModelGenerator State , MyRenderModel { override fun toRenderModel ( state : State ): MyRenderModel { return RenderModel ( onSaveButtonClicked = { // We use the current state to decide which callback to invoke if ( state . isValid ) { saveUserInfo ( state . userInfo ) } else { showValidationError ( Email field is empty. ) } } ) } } We will provide those callbacks in the Render Formula. class MyRenderFormula : RenderFormula Input , State , .., RenderModel { class Input ( val showToast : ( String ) - Unit ) override fun createRenderLoop ( input : Input ): RenderLoop ... { return RenderLoop ( renderModelGenerator = MyRenderModelGenerator ( // There are many options here what to do with a user action. You can: // 1. Escalate it up to the parent by adding a callback to Input // 2. Delegate to another class that was injected through the constructor // 3. Handle it internally by passing the event to a PublishRelay showValidationError = { error - // Let s bubble up this event to the parent of this formula using the Input class input . showToast ( error ) }, saveUserInfo = { info - } ) ) } } Handling User Action Internally This is continuation on the above section. We want to trigger save user info request and update the UI according to request state. // Let s define the repository abstraction for saving user info class SaveUserInfoRepo { fun saveUserInfo ( info : UserInfo ): Observable Lce UserInfoResponse } class MyRenderFormula ( private val repo : SaveUserInfoRepo ) : RenderFormula Input , State , .., RenderModel { override fun createRenderLoop ( input : Input ): RenderLoop ... { // We use a RxRelay library to turn user events into an RxJava stream. You could also use RxJava subjects. val saveUserInfoRelay = PublishRelay . create UserInfo () val saveUserInfoReducer = saveUserInfoRelay // We use switch map to cancel previous computation. // This means if new save info action happens, we // cancel the previous request and create a new one. . switchMap { info - repo . saveUserInfo ( info ) } . map { responseEvent - // We should create a reduce a.k.a. state transformation function here. // How to accomplish that will be shown in a different example. } return RenderLoop ( // Since we only have a single reducer here, we pass it directly. reducers = saveUserInfoReducer , renderModelGenerator = MyRenderModelGenerator ( saveUserInfo = { info - // We pass the action to the relay saveUserInfoRelay . accept ( info ) } ) ) } } Composing Render models Render Models are meant to be composable. You can build bigger Render Models from smaller Render Models. data class CheckboxRenderModel ( val text : String , val isChecked : Boolean , val onToggle : () - Unit ) data class NotificationSettingsRenderModel ( val messagePushNotification : CheckboxRenderModel , val promotionalPushNotifications : CheckboxRenderModel , val marketingEmailNotifications : CheckboxRenderModel , val saveSettingsButton : FooterButtonRenderModel ) You can also do the same in your Render View layer. class CheckboxRenderView ( private val root : View ) : RenderView CheckboxRenderModel { private val checkbox : Checkbox = root . findViewById ( R . id . checkbox ) override val renderer : Renderer CheckboxRenderModel = Renderer . create { model - checkbox . text = model . title checkbox . isChecked = model . isChecked checkbox . setOnCheckedListener { model . onToggle () } } } class NotificationSettingsRenderView ( private val root : View ) : RenderView NotificationSettingsRenderModel { private val messagePushNotification = CheckboxRenderView ( root . findViewById ( R . id . message_push_checkbox )) private val promotionalPushNotifications = CheckboxRenderView ( root . findViewById ( R . id . promotional_push_checkbox )) private val marketingEmailNotifications = CheckboxRenderView ( root . findViewById ( R . id . marketing_email_checkbox )) private val saveButton = FooterButtonRenderView ( root . findViewById ( R . id . save_button )) override val renderer : Renderer NotificationSettingsRenderModel = Renderer . create { model - messagePushNotification . renderer . render ( model . messagePushNotification ) promotionalPushNotifications . renderer . render ( model . promotionalPushNotifications ) marketingEmailNotifications . renderer . render ( model . marketingEmailNotifications ) saveButton . renderer . render ( model . saveSettingsButton ) } } Annotation processor There is an optional annotation processor to remove some of the boiler plate code. It is primarily driven by @State annotation placed on the State data class. @State ( reducers = MyScreenReducers :: class ) data class MyScreenState ( val userInfoRequest : Lce UserInfo , val isSaving : Boolean = false ) class MyScreenReducers : Reducers MyScreenState , Unit () { fun onUserInfoRequest ( event : Lce UserInfo ) = withoutEffects { state - state . copy ( userInfoRequest = event ) } fun onSaveUserInfoRequest ( event : Lce SaveUserInfoResponse ) = withoutEffects { state - state . copy ( isSaving = event . isLoading ()) } } This will generate an Events class that handles binding the RxJava streams to the appropriate event methods defined in the Reducers class. @Generated class MyScreenStateEvents ( private val reducers : MyScreenReducers ) { fun bind ( onUserInfoRequest : Observable Lce UserInfo , onSaveUserInfoRequest : Observable Lce SaveUserInfoResponse ): Observable ... { val list = ArrayList Observable ... () list . add ( onUserInfoRequest . map ( reducers :: onUserInfoRequest )) list . add ( onSaveUserInfoRequest . map ( reducers :: onSaveUserInfoRequest )) return Observable . merge ( list ) } } You can use this Events class within the Render Formula. class MyScreenRenderFormula ( private val userRepo : UserRepo ) : RenderFormula Unit , MyScreenState , FooterButtonRenderModel , Unit { override fun createRenderLoop ( input : Unit ): RenderLoop MyScreenState , Unit , FooterButtonRenderModel { val events = MyScreenStateEvents ( MyScreenReducers ()) return RenderLoop ( ..., reducers = events . bind ( onUserInfoRequest = userRepo . fetchUserInfo (), onSaveUserInfoRequest = ... ) ) } } Using @ExportedProperty Exported Property annotation generates a transformation that updates a single property. @State ( reducers = MyScreenReducers :: class ) data class MyScreenState ( @ExportedProperty val userInfoRequest : Lce UserInfo , ... ) The generated code is equivalent to this snippet, so we can delete it completely from MyScreenReducers. fun onUserInfoRequest ( event : Lce UserInfo ) = withoutEffects { state - state . copy ( userInfoRequest = event ) } Using isDirectInput (@ExportedProperty) Direct input generates a method on Events class that can directly cause a state transformation. @State data class NotificationSettingsState ( @ExportedProperty ( isDirectInput = true ) val isPushNotificationsEnabled : Boolean ) Now you can update this property through the NotificationSettingsStateEvents class. class NotificationSettingsRenderModelGenerator ( private val events : NotificationSettingsStateEvents ): RenderModelGenerator NotificationSettingsState , CheckboxRenderModel { override fun toRenderModel ( state : NotificationSettingsState ): CheckboxRenderModel { return CheckboxRenderModel ( text = Push notifications , isChecked = state . isPushNotificationsEnabled , onToggle = { // We are invoking a generated method. events . onIsPushNotificationsEnabledChanged (! state . isPushNotificationEnabled ) } ) } } Using @DirectInput Direct Input annotation works in similar manner as @ExportedProperty(isDirectInput = true) except you mark transformation methods within the Reducers class instead of properties on State class. class TaskListReducers : Reducers TaskListState , Unit () { @DirectInput fun onTaskCompleted ( taskId : String ) = withoutEffects { state - state . tasks . map { if ( it . id == taskId ) { it . copy ( completed = true ) } else { it } } } } @State ( reducers = TaskListReducers :: class ) data class TaskListState ( val tasks : List Task ) This will generated a method TaskListStateEvents.onTaskCompleted . You can now invoke this method on user input and it will update the state. Navigation TODO","title":"Getting Started"},{"location":"Old-Getting-Started/#getting-started","text":"A functional reactive framework for managing state and side effects based on RxJava. It enables building deterministic, composable, testable applications.","title":"Getting Started"},{"location":"Old-Getting-Started/#core-concepts","text":"","title":"Core concepts"},{"location":"Old-Getting-Started/#state","text":"State is a Kotlin data class that contains all the necessary information to render your view. data class MyScreenState ( val userInfoRequest : Lce UserInfo , val isSaving : Boolean = false ) Note: for info about Lce , please check this article .","title":"State"},{"location":"Old-Getting-Started/#render-model","text":"Render Model is an immutable representation of your view. It will be used to update the Android views. Typically, it will also contain callbacks that will be invoked when user interacts with the UI. data class FooterButtonRenderModel ( val title : String , val isEnabled : Boolean , val onClick : () - Unit )","title":"Render Model"},{"location":"Old-Getting-Started/#render-view","text":"Render view is responsible for taking the Render Model and applying it to the Android views. class FooterButtonRenderView ( private val root : View ) : RenderView FooterButtonRenderModel { private val footerButton : Button = root . findViewById ( R . id . footer_button ) override val renderer : Renderer FooterButtonRenderModel = Renderer . create { model - footerButton . text = model . title footerButton . isEnabled = model . isEnabled footerButton . setOnClickListener { model . onClick () } } }","title":"Render View"},{"location":"Old-Getting-Started/#render-model-generator","text":"Render Model Generator takes a State and creates a Render Model from it. class MyScreenRenderModelGenerator ( private val onSaveUserInfoSelected : () - Unit ) : RenderModelGenerator MyScreenState , FooterButtonRenderModel { override fun toRenderModel ( state : MyScreenState ): FooterButtonRenderModel { return FooterButtonRenderModel ( title = Save User Info , isEnabled = state . userInfoRequest . isData () ! state . isSaving , onClick = onSaveUserInfoSelected ) } }","title":"Render Model Generator"},{"location":"Old-Getting-Started/#reducers","text":"Reducers class defines all the possible State transformations. It defines methods that take an event object and return a transformation. Instead of of mutating properties when an event happens, we create a new version of the State class. To accomplish that, we use data class copy method. class MyScreenReducers : Reducers MyScreenState , Unit () { fun onUserInfoRequest ( event : Lce UserInfo ) = withoutEffects { state - state . copy ( userInfoRequest = event ) } fun onSaveUserInfoRequest ( event : Lce SaveUserInfoResponse ) = withoutEffects { state - state . copy ( isSaving = event . isLoading ()) } }","title":"Reducers"},{"location":"Old-Getting-Started/#render-formula","text":"Render Formula is responsible for state management. It combines various RxJava event streams and maps them to state transformations. class MyScreenRenderFormula ( private val userRepo : UserRepo ) : RenderFormula Unit , MyScreenState , FooterButtonRenderModel , Unit { override fun createRenderLoop ( input : Unit ): RenderLoop MyScreenState , Unit , FooterButtonRenderModel { val reducers = MyScreenReducers () val userInfoRequestChanges = userRepo . fetchUserInfo (). map ( reducers :: onUserInfoRequest ) // We use a RxRelay library to turn user events into an RxJava stream val saveUserInfoRelay = PublishRelay . create Unit () val saveUserInfoChanges = saveUserInfoRelay . switchMap { userRepo . saveUserInfo () } . map ( reducers :: onSaveUserInfoRequest ) return RenderLoop ( initialState = MyScreenState ( userInfoRequest = Lce . loading () ), reducers = Observable . merge ( userInfoRequestChanges , saveUserInfoChanges ), renderModelGenerator = MyScreeenRenderModelGenerator ( onSaveUserInfoSelected = { saveUserInfoRelay . accept ( Unit ) } ) ) } }","title":"Render Formula"},{"location":"Old-Getting-Started/#using-render-formula","text":"Render formula is agnostic to other layers of abstraction. It can be used within activity or a fragment. Ideally, it would be placed within a surface that survives configuration changes such as Android Components ViewModel. In this example, I'll show how to connect RenderFormula using Formula Android module. Let's first define our Activity. class MyActivity : FormulaAppCompatActivity () { lateinit var footerButtonRenderView : FooterButtonRenderView override fun onCreate ( state : Bundle ?) { super . onCreate ( state ) setContentView ( R . string . my_screen ) footerButtonRenderView = FooterButtonRenderView ( findViewById ( R . id . footer )) } fun render ( model : FooterButtonRenderModel ) { footerButtonRenderView . renderer . render ( model ) } } Now, let's connect MyScreenRenderFormula to MyActivity.render function. class MyApp : Application () { override fun onCreate () { super . onCreate () FormulaAndroid . init ( this ) { activity MyActivity { store ( streams = { val formula : MyScreenRenderFormula = ... update ( formula . state ( Unit ), MyActivity :: render ) } ) } } } } And that's it. To learn more, see our Formula Android Guide .","title":"Using Render Formula"},{"location":"Old-Getting-Started/#using-render-formula-with-android-view-model","text":"Defining ViewModel which runs Formula.state stream until onCleared is called. class MyViewModel ( private val formula : MyScreenRenderFormula ) : ViewModel { private val disposables = CompositeDisposable () val renderModels = formula . state ( Unit ). replay ( 1 ). apply { connect { disposables . add ( it ) } } override fun onCleared () { super . onCleared () disposables . clear () } } In our activity, we then subscribe to the Render Model changes and pass them to the Render View. class MyActivity : AppCompatActivity () { private val disposables = CompositeDisposable () override fun onCreate ( state : Bundle ?) { super . onCreate ( state ) setContentView ( R . string . my_screen ) val renderView = FooterButtonRenderView ( findViewById ( R . id . activity_content )) val viewModel = ViewModelProviders . of ( this ). get ( MyViewModel :: class . java ) disposables . add ( viewModel . renderModels . subscribe ( renderView . renderer :: render )) } override fun onDestroy () { disposables . clear () super . onDestroy () } }","title":"Using Render Formula with Android View Model"},{"location":"Old-Getting-Started/#input","text":"Input is used to pass information when creating a state stream. Typically it will contain data necessary to initialize the state streams, and callbacks for events that the parent should be aware of. class ItemDetailRenderFormula () : RenderFormula Input , ..., ..., ... { class Input ( val itemId : String , val onItemDeleted : () - Unit ) override fun createRenderLoop ( input : Input ): RenderLoop ... { // We can use the input here to fetch the item from the repo. // We can also notify the parent when the item is deleted using input.onItemDeleted() } }","title":"Input"},{"location":"Old-Getting-Started/#effects","text":"Effects are message objects used to request the execution of impure code. Operations such as firing a network request, reading / writing to disk, navigation or updating global state are considered side-effects. Instead of performing those operations within the Reducers class, we return the Effect object and let the caller execute the side effect. Typically, we define all possible side-effects as a sealed Kotlin class. sealed class MyScreenEffect { data class ShowErrorModal ( val errorMessage : String ): MyScreenEffect () data class Exit ( val savedUserInfo : Boolean ): MyScreenEffect () } To emit effect class MyScreenReducers : Reducers ..., MyScreenEffect () { fun onSaveUserInfoRequest ( event : Lce SaveUserInfoResponse ) = reduce { val updated = it . copy ( isSaving = event . isLoading ()) // Check if there are side effects val effect = if ( event . isData ()) { // We want to close the screen when user info is saved. MyScreenEffect . Exit ( savedUserInfo = true ) } else if ( event . isError ()) { MyScreenEffect . ShowErrorModal ( errorMessage = event . error . getMessage ()) } else { null } updated . withOptionalEffect ( effect ) } } Within the Render Formula, we can decide how to handle the effects. class MyScreenRenderFormula : RenderFormula ..., ..., MyScreenEffect , ... { override fun createRenderLoop ( input : ...): RenderLoop ..., MyScreenEffect , ... { return RenderLoop ( ..., onEffect = { effect - // We decide here how to execute the effect. We can // 1. bubble it to the parent using the callbacks passed by the Input object // 2. handle it internally by passing it to a RxRelay or RxJava Subject when ( effect ) { is ShowErrorModal - { } is Exit - { } } } ) } }","title":"Effects"},{"location":"Old-Getting-Started/#handling-user-ui-actions","text":"To handle user UI actions, we set listeners on Android Views and delegate to the callbacks on the Render Model. data class MyRenderModel ( // Defining a callback for a user action. // Usually, callback will not take any parameters. val onSaveButtonClicked : () - Unit ) class MyRenderView (...) : RenderView MyRenderModel { val saveButton : TextView = ... override val renderer : Renderer MyRenderModel = Renderer . create { model - // We just set a click listener and delegate to the callback on the Render Model. saveButton . setOnClickListener { model . onSaveButtonClicked () } } } The Render Model creation will be scoped to the current state object, so we can use it to decide how we should bubble it up. class MyRenderModelGenerator ( // We splitting save button click into two options private val showValidationError : ( String ) - Unit , private val saveUserInfo : ( UserInfo ) - Unit ) : RenderModelGenerator State , MyRenderModel { override fun toRenderModel ( state : State ): MyRenderModel { return RenderModel ( onSaveButtonClicked = { // We use the current state to decide which callback to invoke if ( state . isValid ) { saveUserInfo ( state . userInfo ) } else { showValidationError ( Email field is empty. ) } } ) } } We will provide those callbacks in the Render Formula. class MyRenderFormula : RenderFormula Input , State , .., RenderModel { class Input ( val showToast : ( String ) - Unit ) override fun createRenderLoop ( input : Input ): RenderLoop ... { return RenderLoop ( renderModelGenerator = MyRenderModelGenerator ( // There are many options here what to do with a user action. You can: // 1. Escalate it up to the parent by adding a callback to Input // 2. Delegate to another class that was injected through the constructor // 3. Handle it internally by passing the event to a PublishRelay showValidationError = { error - // Let s bubble up this event to the parent of this formula using the Input class input . showToast ( error ) }, saveUserInfo = { info - } ) ) } }","title":"Handling User UI Actions"},{"location":"Old-Getting-Started/#handling-user-action-internally","text":"This is continuation on the above section. We want to trigger save user info request and update the UI according to request state. // Let s define the repository abstraction for saving user info class SaveUserInfoRepo { fun saveUserInfo ( info : UserInfo ): Observable Lce UserInfoResponse } class MyRenderFormula ( private val repo : SaveUserInfoRepo ) : RenderFormula Input , State , .., RenderModel { override fun createRenderLoop ( input : Input ): RenderLoop ... { // We use a RxRelay library to turn user events into an RxJava stream. You could also use RxJava subjects. val saveUserInfoRelay = PublishRelay . create UserInfo () val saveUserInfoReducer = saveUserInfoRelay // We use switch map to cancel previous computation. // This means if new save info action happens, we // cancel the previous request and create a new one. . switchMap { info - repo . saveUserInfo ( info ) } . map { responseEvent - // We should create a reduce a.k.a. state transformation function here. // How to accomplish that will be shown in a different example. } return RenderLoop ( // Since we only have a single reducer here, we pass it directly. reducers = saveUserInfoReducer , renderModelGenerator = MyRenderModelGenerator ( saveUserInfo = { info - // We pass the action to the relay saveUserInfoRelay . accept ( info ) } ) ) } }","title":"Handling User Action Internally"},{"location":"Old-Getting-Started/#composing-render-models","text":"Render Models are meant to be composable. You can build bigger Render Models from smaller Render Models. data class CheckboxRenderModel ( val text : String , val isChecked : Boolean , val onToggle : () - Unit ) data class NotificationSettingsRenderModel ( val messagePushNotification : CheckboxRenderModel , val promotionalPushNotifications : CheckboxRenderModel , val marketingEmailNotifications : CheckboxRenderModel , val saveSettingsButton : FooterButtonRenderModel ) You can also do the same in your Render View layer. class CheckboxRenderView ( private val root : View ) : RenderView CheckboxRenderModel { private val checkbox : Checkbox = root . findViewById ( R . id . checkbox ) override val renderer : Renderer CheckboxRenderModel = Renderer . create { model - checkbox . text = model . title checkbox . isChecked = model . isChecked checkbox . setOnCheckedListener { model . onToggle () } } } class NotificationSettingsRenderView ( private val root : View ) : RenderView NotificationSettingsRenderModel { private val messagePushNotification = CheckboxRenderView ( root . findViewById ( R . id . message_push_checkbox )) private val promotionalPushNotifications = CheckboxRenderView ( root . findViewById ( R . id . promotional_push_checkbox )) private val marketingEmailNotifications = CheckboxRenderView ( root . findViewById ( R . id . marketing_email_checkbox )) private val saveButton = FooterButtonRenderView ( root . findViewById ( R . id . save_button )) override val renderer : Renderer NotificationSettingsRenderModel = Renderer . create { model - messagePushNotification . renderer . render ( model . messagePushNotification ) promotionalPushNotifications . renderer . render ( model . promotionalPushNotifications ) marketingEmailNotifications . renderer . render ( model . marketingEmailNotifications ) saveButton . renderer . render ( model . saveSettingsButton ) } }","title":"Composing Render models"},{"location":"Old-Getting-Started/#annotation-processor","text":"There is an optional annotation processor to remove some of the boiler plate code. It is primarily driven by @State annotation placed on the State data class. @State ( reducers = MyScreenReducers :: class ) data class MyScreenState ( val userInfoRequest : Lce UserInfo , val isSaving : Boolean = false ) class MyScreenReducers : Reducers MyScreenState , Unit () { fun onUserInfoRequest ( event : Lce UserInfo ) = withoutEffects { state - state . copy ( userInfoRequest = event ) } fun onSaveUserInfoRequest ( event : Lce SaveUserInfoResponse ) = withoutEffects { state - state . copy ( isSaving = event . isLoading ()) } } This will generate an Events class that handles binding the RxJava streams to the appropriate event methods defined in the Reducers class. @Generated class MyScreenStateEvents ( private val reducers : MyScreenReducers ) { fun bind ( onUserInfoRequest : Observable Lce UserInfo , onSaveUserInfoRequest : Observable Lce SaveUserInfoResponse ): Observable ... { val list = ArrayList Observable ... () list . add ( onUserInfoRequest . map ( reducers :: onUserInfoRequest )) list . add ( onSaveUserInfoRequest . map ( reducers :: onSaveUserInfoRequest )) return Observable . merge ( list ) } } You can use this Events class within the Render Formula. class MyScreenRenderFormula ( private val userRepo : UserRepo ) : RenderFormula Unit , MyScreenState , FooterButtonRenderModel , Unit { override fun createRenderLoop ( input : Unit ): RenderLoop MyScreenState , Unit , FooterButtonRenderModel { val events = MyScreenStateEvents ( MyScreenReducers ()) return RenderLoop ( ..., reducers = events . bind ( onUserInfoRequest = userRepo . fetchUserInfo (), onSaveUserInfoRequest = ... ) ) } }","title":"Annotation processor"},{"location":"Old-Getting-Started/#using-exportedproperty","text":"Exported Property annotation generates a transformation that updates a single property. @State ( reducers = MyScreenReducers :: class ) data class MyScreenState ( @ExportedProperty val userInfoRequest : Lce UserInfo , ... ) The generated code is equivalent to this snippet, so we can delete it completely from MyScreenReducers. fun onUserInfoRequest ( event : Lce UserInfo ) = withoutEffects { state - state . copy ( userInfoRequest = event ) }","title":"Using @ExportedProperty"},{"location":"Old-Getting-Started/#using-isdirectinput-exportedproperty","text":"Direct input generates a method on Events class that can directly cause a state transformation. @State data class NotificationSettingsState ( @ExportedProperty ( isDirectInput = true ) val isPushNotificationsEnabled : Boolean ) Now you can update this property through the NotificationSettingsStateEvents class. class NotificationSettingsRenderModelGenerator ( private val events : NotificationSettingsStateEvents ): RenderModelGenerator NotificationSettingsState , CheckboxRenderModel { override fun toRenderModel ( state : NotificationSettingsState ): CheckboxRenderModel { return CheckboxRenderModel ( text = Push notifications , isChecked = state . isPushNotificationsEnabled , onToggle = { // We are invoking a generated method. events . onIsPushNotificationsEnabledChanged (! state . isPushNotificationEnabled ) } ) } }","title":"Using isDirectInput (@ExportedProperty)"},{"location":"Old-Getting-Started/#using-directinput","text":"Direct Input annotation works in similar manner as @ExportedProperty(isDirectInput = true) except you mark transformation methods within the Reducers class instead of properties on State class. class TaskListReducers : Reducers TaskListState , Unit () { @DirectInput fun onTaskCompleted ( taskId : String ) = withoutEffects { state - state . tasks . map { if ( it . id == taskId ) { it . copy ( completed = true ) } else { it } } } } @State ( reducers = TaskListReducers :: class ) data class TaskListState ( val tasks : List Task ) This will generated a method TaskListStateEvents.onTaskCompleted . You can now invoke this method on user input and it will update the state.","title":"Using @DirectInput"},{"location":"Old-Getting-Started/#navigation","text":"TODO","title":"Navigation"},{"location":"State-Render-Model-Separation/","text":"Why state render model separation This allows us to keep the view very stupid. Let's say we have a state class such as this data class State ( val userInfo : Lce UserInfo , val saveRequest : Lce SaveResponse ? = null ) // UI layer now has to contain logic to process these properties. fun render ( state : State ) { saveButton . isEnabled = state . userInfo . hasData () ( state . saveRequest == null ! state . saveRequest . isLoading ()) } To avoid having such logic in the view, we have created the RenderModel concept. data class RenderModel ( val isSaveEnabled : Boolean ) The logic where we do this transformation is encapsulated in the RenderModelGenerator. class MyRenderModelGenerator : RenderModelGenerator State , RenderModel { override fun toRenderModel ( state : State ): RenderModel { return RenderModel ( isSaveEnabled = state . userInfo . hasData () ( state . saveRequest == null ! state . saveRequest . isLoading ()) ) } } Now, the UI would receive a RenderModel instead of State. Also, we can now easily unit test that logic separately from the view.","title":"State Render Model Separation"},{"location":"State-Render-Model-Separation/#why-state-render-model-separation","text":"This allows us to keep the view very stupid. Let's say we have a state class such as this data class State ( val userInfo : Lce UserInfo , val saveRequest : Lce SaveResponse ? = null ) // UI layer now has to contain logic to process these properties. fun render ( state : State ) { saveButton . isEnabled = state . userInfo . hasData () ( state . saveRequest == null ! state . saveRequest . isLoading ()) } To avoid having such logic in the view, we have created the RenderModel concept. data class RenderModel ( val isSaveEnabled : Boolean ) The logic where we do this transformation is encapsulated in the RenderModelGenerator. class MyRenderModelGenerator : RenderModelGenerator State , RenderModel { override fun toRenderModel ( state : State ): RenderModel { return RenderModel ( isSaveEnabled = state . userInfo . hasData () ( state . saveRequest == null ! state . saveRequest . isLoading ()) ) } } Now, the UI would receive a RenderModel instead of State. Also, we can now easily unit test that logic separately from the view.","title":"Why state &amp; render model separation"},{"location":"composition/","text":"Composing Render models Render Models are meant to be composable. You can build bigger Render Models from smaller Render Models. data class CheckboxRenderModel ( val text : String , val isChecked : Boolean , val onToggle : () - Unit ) data class NotificationSettingsRenderModel ( val messagePushNotification : CheckboxRenderModel , val promotionalPushNotifications : CheckboxRenderModel , val marketingEmailNotifications : CheckboxRenderModel , val saveSettingsButton : FooterButtonRenderModel ) You can also do the same in your Render View layer. class CheckboxRenderView ( private val root : View ) : RenderView CheckboxRenderModel { private val checkbox : Checkbox = root . findViewById ( R . id . checkbox ) override val renderer : Renderer CheckboxRenderModel = Renderer . create { model - checkbox . text = model . title checkbox . isChecked = model . isChecked checkbox . setOnCheckedListener { model . onToggle () } } } class NotificationSettingsRenderView ( private val root : View ) : RenderView NotificationSettingsRenderModel { private val messagePushNotification = CheckboxRenderView ( root . findViewById ( R . id . message_push_checkbox )) private val promotionalPushNotifications = CheckboxRenderView ( root . findViewById ( R . id . promotional_push_checkbox )) private val marketingEmailNotifications = CheckboxRenderView ( root . findViewById ( R . id . marketing_email_checkbox )) private val saveButton = FooterButtonRenderView ( root . findViewById ( R . id . save_button )) override val renderer : Renderer NotificationSettingsRenderModel = Renderer . create { model - messagePushNotification . renderer . render ( model . messagePushNotification ) promotionalPushNotifications . renderer . render ( model . promotionalPushNotifications ) marketingEmailNotifications . renderer . render ( model . marketingEmailNotifications ) saveButton . renderer . render ( model . saveSettingsButton ) } } Composing formulas You can pass other formulas through the constructor class MainPageFormula ( val headerFormula : HeaderFormula , val listFormula : ListFormula , val dialogFormula : DialogFormula ) : Formula Use FormulaContext.child within Formula.evaluate to hook them up. val listRenderModel = context . child ( listFormula ) . input { ListInput ( items = state . items , onItemSelected = context . eventCallback { // you can respond to child event } } Here is a more complete example: class MainPageFormula ( val headerFormula : HeaderFormula , val listFormula : ListFormula , val dialogFormula : DialogFormula ) : Formula { override fun evaluate ( input : Unit , state : MyState , context : FormulaContext ... ): Evaluation ... { // context.child returns a RenderModel val listRenderModel = context . child ( listFormula ) . input { createListInput ( state ) } val headerRenderModel = context . child ( headerFormula ) . input { createHeaderInput ( state ) } // We can make decisions using the current `state` about // what children to show val dialog = if ( state . showDialog ) { context . child ( dialogFormula ) . input ( Unit ) } else { null } return Evaluation ( renderModel = MainRenderModel ( header = headerRenderModel , list = listRenderModel , dialog = dialog ) ) } }","title":"Composition"},{"location":"composition/#composing-render-models","text":"Render Models are meant to be composable. You can build bigger Render Models from smaller Render Models. data class CheckboxRenderModel ( val text : String , val isChecked : Boolean , val onToggle : () - Unit ) data class NotificationSettingsRenderModel ( val messagePushNotification : CheckboxRenderModel , val promotionalPushNotifications : CheckboxRenderModel , val marketingEmailNotifications : CheckboxRenderModel , val saveSettingsButton : FooterButtonRenderModel ) You can also do the same in your Render View layer. class CheckboxRenderView ( private val root : View ) : RenderView CheckboxRenderModel { private val checkbox : Checkbox = root . findViewById ( R . id . checkbox ) override val renderer : Renderer CheckboxRenderModel = Renderer . create { model - checkbox . text = model . title checkbox . isChecked = model . isChecked checkbox . setOnCheckedListener { model . onToggle () } } } class NotificationSettingsRenderView ( private val root : View ) : RenderView NotificationSettingsRenderModel { private val messagePushNotification = CheckboxRenderView ( root . findViewById ( R . id . message_push_checkbox )) private val promotionalPushNotifications = CheckboxRenderView ( root . findViewById ( R . id . promotional_push_checkbox )) private val marketingEmailNotifications = CheckboxRenderView ( root . findViewById ( R . id . marketing_email_checkbox )) private val saveButton = FooterButtonRenderView ( root . findViewById ( R . id . save_button )) override val renderer : Renderer NotificationSettingsRenderModel = Renderer . create { model - messagePushNotification . renderer . render ( model . messagePushNotification ) promotionalPushNotifications . renderer . render ( model . promotionalPushNotifications ) marketingEmailNotifications . renderer . render ( model . marketingEmailNotifications ) saveButton . renderer . render ( model . saveSettingsButton ) } }","title":"Composing Render models"},{"location":"composition/#composing-formulas","text":"You can pass other formulas through the constructor class MainPageFormula ( val headerFormula : HeaderFormula , val listFormula : ListFormula , val dialogFormula : DialogFormula ) : Formula Use FormulaContext.child within Formula.evaluate to hook them up. val listRenderModel = context . child ( listFormula ) . input { ListInput ( items = state . items , onItemSelected = context . eventCallback { // you can respond to child event } } Here is a more complete example: class MainPageFormula ( val headerFormula : HeaderFormula , val listFormula : ListFormula , val dialogFormula : DialogFormula ) : Formula { override fun evaluate ( input : Unit , state : MyState , context : FormulaContext ... ): Evaluation ... { // context.child returns a RenderModel val listRenderModel = context . child ( listFormula ) . input { createListInput ( state ) } val headerRenderModel = context . child ( headerFormula ) . input { createHeaderInput ( state ) } // We can make decisions using the current `state` about // what children to show val dialog = if ( state . showDialog ) { context . child ( dialogFormula ) . input ( Unit ) } else { null } return Evaluation ( renderModel = MainRenderModel ( header = headerRenderModel , list = listRenderModel , dialog = dialog ) ) } }","title":"Composing formulas"},{"location":"contributing/","text":"TODO...","title":"Contributing"},{"location":"diffing/","text":"TODO Diffing Given that we recompute everything with each state change, there is an internal diffing mechanism with Formula. This mechanism ensures that: 1. RxJava streams are only subscribed to once. 2. Children state is persisted across every processing pass.","title":"Diffing"},{"location":"diffing/#diffing","text":"Given that we recompute everything with each state change, there is an internal diffing mechanism with Formula. This mechanism ensures that: 1. RxJava streams are only subscribed to once. 2. Children state is persisted across every processing pass.","title":"Diffing"},{"location":"faq/","text":"Only thread that created it can trigger transitions The state management should be initialized on the main thread and all the transitions should also happen on the main thread. You will get the following exception if that is not the case. Caused by: java.lang.IllegalStateException: Only thread that created it can trigger transitions. Expected: main, Was: Network 1 Transition already happened. After each transition, formula is re-evaluated and new event listeners are created. If you use an old listener you will see the following exception. Caused by: java.lang.IllegalStateException: Transition already happened. This is using old transition callback: $it. Callback is already defined. TODO..","title":"FAQ"},{"location":"faq/#only-thread-that-created-it-can-trigger-transitions","text":"The state management should be initialized on the main thread and all the transitions should also happen on the main thread. You will get the following exception if that is not the case. Caused by: java.lang.IllegalStateException: Only thread that created it can trigger transitions. Expected: main, Was: Network 1","title":"Only thread that created it can trigger transitions"},{"location":"faq/#transition-already-happened","text":"After each transition, formula is re-evaluated and new event listeners are created. If you use an old listener you will see the following exception. Caused by: java.lang.IllegalStateException: Transition already happened. This is using old transition callback: $it.","title":"Transition already happened."},{"location":"faq/#callback-is-already-defined","text":"TODO..","title":"Callback is already defined."},{"location":"input/","text":"Input is a Kotlin data class used to pass data and message handlers to the Formula instance. Let's say we need to pass an item id to ItemDetailFormula . class ItemDetailFormula () : Formula ItemDetailFormula . Input , ..., ... { // Input declaration data class Input ( val itemId : String ) // Use input to initialize state override fun initialState ( input : Input ): State = ... // Respond to Input changes. override fun onInputChanged ( oldInput : Input , input : Input , state : State ): State { // We can compare old and new inputs and create // a new state before `Formula.evaluate` is called. return state } // Using input within evaluate block override fun evaluate ( input : Input , state : .., context : .. ): Evaluation ... { val itemId = input . itemId // We can use the input here to fetch the item from the repo. } } To pass the input to ItemDetailFormula val itemDetailFormula : ItemDetailFormula = ... itemDetailFormula . state ( ItemDetailFormula . Input ( itemId = 1 )) . subscribe { renderModel - } You could also pass an Observable ItemDetailFormula.Input val itemDetailInput : Observable ItemDetailFormula . Input = ... itemDetailFormula . state ( itemDetailInput ) . subscribe { renderModel - }","title":"Using Input"},{"location":"messages/","text":"Messages are objects used to request execution of impure code. Use messages to execute operations such as logging, database updates, firing network requests, notifying a parent and etc. Receive UI messages To listen and respond to UI events, declare a callback on the Render Model for each type of UI event you care about. data class FormRenderModel ( val email : String , val onEmailChanged : ( String ) - Unit , val onSaveSelected : () - Unit ) Use FormulaContext.callback and FormulaContext.eventCallback within Formula.evaluate block to create them. FormRenderModel ( email = state . email , onEmailChanged = context . eventCallback { newEmail - state . copy ( email = newEmail ). noMessages () }, onSaveSelected = context . callback { message ( userService :: updateEmail , state . email ) } ) We need to return a Transition State within each of the callbacks. Transition enables you to specify a new state and/or send 0..N messages. It uses Kotlin receiver parameter to provide you with noMessages and message utility functions to construct a transition. Take a look at Transition.Factory for all available utilities. Note : FormulaContext.callback takes no parameters and FormulaContext.eventCallback takes one generic parameter. Sending a message For example, lets say we want to fire analytics event when user clicks a button. class UserProfileFormula ( val userAnalyticsService : UserAnalyticsService ) : Formula ... { override fun evaluate (...): Evaluation UserProfileRenderModel { return Evaluation ( renderModel = UserProfileRenderModel ( onSaveSelected = context . callback { message ( userAnalyticsService :: trackSaveSelected ) } ) ) } } The main part is the declaration within the context.callback block. context . callback { // We do a state transition and declare 0..N messages that we want to execute. } Sending messages to the parent To pass events to the parent, we need to first define the callbacks on the Formula.Input class. data class ItemListInput ( val onItemSelected : ( itemId : String ) - Unit ) Also, lets make sure that Input type is declared at the top of our formula . class ItemListFormula () : Formula ItemListInput , ..., ... Now, we can use the the Message API and the input passed to us in Formula.evaluate to communicate with the parent. override fun evaluate ( input : ItemListInput , state : .., context : .. ): Evaluation ... { return Evaluation ( renderModel = state . items . map { item - context . key ( item . id ) { ItemRow ( name = item . name , onClick = context . callback { // sending a message to `input.onItemSelected` with parameter `item.id` message ( input . onItemSelected , item . id ) } ) } } ) } Note: instead of calling input.onItemSelected(item.id) , we call message(input.onItemSelected, item.id) . This allows formula runtime to ensure that parent is in the right state to handle the message. Receiving asynchronous events Formula uses RxJava to deal with event streams. You can either use Observable directly or wrap it in a RxStream . Usually event stream dependencies will be passed/injected through the constructor. class MyFormula ( private val dataObservable : Observable MyData ): Formula .... To listen to your data observable, you need to declare a binding within Formula.evaluate block. Evaluation ( renderModel = ..., // We declare the event streams within `updates` block updates = context . updates { events ( data , dataObservable ) { update : MyData - // the listener is always scoped to the current `state` so you can update it as part of the transition state . copy ( myData = update ). noMessages () } } ) Note: we use a unique identifier \"data\" to make sure that internal diffing mechanism can distinguish between different streams. Formula retains callbacks Callbacks retain equality across re-evaluation (such as state changes). By default, we persist the callback in a map where each callback is identified by its class type. There a couple of cases when this is not sufficient and you need to explicitly provide a unique key . Case 1: Declaring callbacks within a loop For example, if you are mapping list of items and creating a callback within the map function. // This will not work unless your list of items never changes (removal of item or position change). ItemListRenderModel ( items = state . items . map { item - ItemRenderModel ( name = item . name , onSelected = context . callback { // perform a transition } ) } ) To fix it, you should wrap ItemRenderModel creation block in context.key where you pass it an item id . context . key ( item . id ) { ItemRenderModel ( name = item . name , onSelected = context . callback { // perform a transition } ) } Case 2: Delegating to another function There is an issue with callbacks when passing FormulaContext to another function. Let's say you have a function that takes FormulaContext and creates a ChildRenderModel. fun createChildRenderModel ( context : FormulaContext ... ): ChildRenderModel { return ChildRenderModel ( onClick = context . callback {} ) } There is no problem calling it once, but there will be key collisions if you call it multiple times: RenderModel ( // First child is created with no problem first = createChildRenderModel ( context ), // Calling it again will crash second = createChildRenderModel ( context ) ) To fix it, wrap createChildRenderModel with context.key block. RenderModel ( first = context . key ( first ) { createChildRenderModel ( context ) }, second = context . key ( second ) { createChildRenderModel ( context ) } ) More info For each unique key we have a persisted callback instance that is kept across multiple Formula.evaluate calls. The instance is disabled and removed when your Formula is removed or if you don't create this callback in the current Formula.evaluate call.","title":"Messages"},{"location":"messages/#receive-ui-messages","text":"To listen and respond to UI events, declare a callback on the Render Model for each type of UI event you care about. data class FormRenderModel ( val email : String , val onEmailChanged : ( String ) - Unit , val onSaveSelected : () - Unit ) Use FormulaContext.callback and FormulaContext.eventCallback within Formula.evaluate block to create them. FormRenderModel ( email = state . email , onEmailChanged = context . eventCallback { newEmail - state . copy ( email = newEmail ). noMessages () }, onSaveSelected = context . callback { message ( userService :: updateEmail , state . email ) } ) We need to return a Transition State within each of the callbacks. Transition enables you to specify a new state and/or send 0..N messages. It uses Kotlin receiver parameter to provide you with noMessages and message utility functions to construct a transition. Take a look at Transition.Factory for all available utilities. Note : FormulaContext.callback takes no parameters and FormulaContext.eventCallback takes one generic parameter.","title":"Receive UI messages"},{"location":"messages/#sending-a-message","text":"For example, lets say we want to fire analytics event when user clicks a button. class UserProfileFormula ( val userAnalyticsService : UserAnalyticsService ) : Formula ... { override fun evaluate (...): Evaluation UserProfileRenderModel { return Evaluation ( renderModel = UserProfileRenderModel ( onSaveSelected = context . callback { message ( userAnalyticsService :: trackSaveSelected ) } ) ) } } The main part is the declaration within the context.callback block. context . callback { // We do a state transition and declare 0..N messages that we want to execute. }","title":"Sending a message"},{"location":"messages/#sending-messages-to-the-parent","text":"To pass events to the parent, we need to first define the callbacks on the Formula.Input class. data class ItemListInput ( val onItemSelected : ( itemId : String ) - Unit ) Also, lets make sure that Input type is declared at the top of our formula . class ItemListFormula () : Formula ItemListInput , ..., ... Now, we can use the the Message API and the input passed to us in Formula.evaluate to communicate with the parent. override fun evaluate ( input : ItemListInput , state : .., context : .. ): Evaluation ... { return Evaluation ( renderModel = state . items . map { item - context . key ( item . id ) { ItemRow ( name = item . name , onClick = context . callback { // sending a message to `input.onItemSelected` with parameter `item.id` message ( input . onItemSelected , item . id ) } ) } } ) } Note: instead of calling input.onItemSelected(item.id) , we call message(input.onItemSelected, item.id) . This allows formula runtime to ensure that parent is in the right state to handle the message.","title":"Sending messages to the parent"},{"location":"messages/#receiving-asynchronous-events","text":"Formula uses RxJava to deal with event streams. You can either use Observable directly or wrap it in a RxStream . Usually event stream dependencies will be passed/injected through the constructor. class MyFormula ( private val dataObservable : Observable MyData ): Formula .... To listen to your data observable, you need to declare a binding within Formula.evaluate block. Evaluation ( renderModel = ..., // We declare the event streams within `updates` block updates = context . updates { events ( data , dataObservable ) { update : MyData - // the listener is always scoped to the current `state` so you can update it as part of the transition state . copy ( myData = update ). noMessages () } } ) Note: we use a unique identifier \"data\" to make sure that internal diffing mechanism can distinguish between different streams.","title":"Receiving asynchronous events"},{"location":"messages/#formula-retains-callbacks","text":"Callbacks retain equality across re-evaluation (such as state changes). By default, we persist the callback in a map where each callback is identified by its class type. There a couple of cases when this is not sufficient and you need to explicitly provide a unique key .","title":"Formula retains callbacks"},{"location":"messages/#case-1-declaring-callbacks-within-a-loop","text":"For example, if you are mapping list of items and creating a callback within the map function. // This will not work unless your list of items never changes (removal of item or position change). ItemListRenderModel ( items = state . items . map { item - ItemRenderModel ( name = item . name , onSelected = context . callback { // perform a transition } ) } ) To fix it, you should wrap ItemRenderModel creation block in context.key where you pass it an item id . context . key ( item . id ) { ItemRenderModel ( name = item . name , onSelected = context . callback { // perform a transition } ) }","title":"Case 1: Declaring callbacks within a loop"},{"location":"messages/#case-2-delegating-to-another-function","text":"There is an issue with callbacks when passing FormulaContext to another function. Let's say you have a function that takes FormulaContext and creates a ChildRenderModel. fun createChildRenderModel ( context : FormulaContext ... ): ChildRenderModel { return ChildRenderModel ( onClick = context . callback {} ) } There is no problem calling it once, but there will be key collisions if you call it multiple times: RenderModel ( // First child is created with no problem first = createChildRenderModel ( context ), // Calling it again will crash second = createChildRenderModel ( context ) ) To fix it, wrap createChildRenderModel with context.key block. RenderModel ( first = context . key ( first ) { createChildRenderModel ( context ) }, second = context . key ( second ) { createChildRenderModel ( context ) } )","title":"Case 2: Delegating to another function"},{"location":"messages/#more-info","text":"For each unique key we have a persisted callback instance that is kept across multiple Formula.evaluate calls. The instance is disabled and removed when your Formula is removed or if you don't create this callback in the current Formula.evaluate call.","title":"More info"},{"location":"testing/","text":"To simplify testing your Formulas, you can use formula-test module. testImplementation com.github.instacart:formula-test:{latest_version} Testing the last render model emission val subject = MyFormula (). test (). renderModel { assertThat ( this . name ). isEqualTo ( my name ) } If your Formula has children, you can replace their render model output val subject = MyFormula (). test { // Note: we are using mockito to mock ChildRenderModel, you could also manually create it. child ( MyChildFormula :: class , mock ChildRenderModel ()) } To inspect the input that was passed to the child subject . childInput ( MyChildFormula :: class ) { assertThat ( this . property ). isEqualTo ( property ) } You can fake child events subject . childInput ( MyChildFormula :: class ) { this . onEvent ( fake data ) }","title":"Testing"},{"location":"using_android_view_model/","text":"Define ViewModel which runs Formula.state stream until onCleared is called. class CounterViewModel () : ViewModel { private val formula = CounterFormula () private val disposables = CompositeDisposable () val renderModels = formula . state ( Unit ). replay ( 1 ). apply { connect { disposables . add ( it ) } } override fun onCleared () { super . onCleared () disposables . clear () } } In our activity, we then subscribe to the Render Model changes and pass them to the Render View. class MyActivity : AppCompatActivity () { private val disposables = CompositeDisposable () override fun onCreate ( state : Bundle ?) { super . onCreate ( state ) setContentView ( R . string . my_screen ) val renderView = CounterRenderView ( findViewById ( R . id . counter )) val viewModel = ViewModelProviders . of ( this ). get ( CounterViewModel :: class . java ) disposables . add ( viewModel . renderModels . subscribe ( renderView . renderer :: render )) } override fun onDestroy () { disposables . clear () super . onDestroy () } }","title":"Using Android View Model"}]}